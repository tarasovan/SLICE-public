package com.nih.slice.parser;

import static java.io.File.separator;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.openscience.cdk.CDKConstants;
import org.openscience.cdk.DefaultChemObjectBuilder;
import org.openscience.cdk.config.Elements;
import org.openscience.cdk.depict.DepictionGenerator;
import org.openscience.cdk.exception.CDKException;
import org.openscience.cdk.fingerprint.CircularFingerprinter;
import org.openscience.cdk.fingerprint.IFingerprinter;
import org.openscience.cdk.interfaces.IAtom;
import org.openscience.cdk.interfaces.IAtomContainer;
import org.openscience.cdk.interfaces.IBond;
import org.openscience.cdk.interfaces.IChemObject;
import org.openscience.cdk.interfaces.IRingSet;

import com.nih.slice.cdk.ExtractSubjectFromAtomContainer;
import com.nih.slice.cdk.SliceConstants;
import com.nih.slice.config.SliceAtom;
import com.nih.slice.config.SliceBond;
import com.nih.slice.config.SliceGroup;
import com.nih.slice.config.SliceSet;
import com.nih.slice.config.SliceType;
import com.nih.slice.config.SliceAtom.atomProp;
import com.nih.slice.config.SliceBond.bondProp;
import com.nih.slice.config.SliceType.ChemicalObject;
import com.nih.slice.parser.SliceParser.TestContext;
import com.nih.tools.Tools;

/**
 * SliceFacade is a class, which link the grammar contains in the Slice.g4 with the alogrithms to apply as a function of 
 * a parsed rule. For instance, in the logic if atom 1 is aromatic, atom 1 must be extracted from an AtomContainer 
 * and needs to be tested if it's aromatic. This is the purpose of this class, which overrides ANTLR parsing functions.
 * Functions that are not override will simply stream the results returned by an override child function.
 * 
 * Every parser rules (lower case word followed by :) in the G4 has a parsing function associated, which was 
 * autogenerated by ANTLR. The name of the function start with visit and is followed by the rule's name with a capital.
 * For instance, the parser rule func_stmt has a parsing function named as visitFunc_stmt. All functions in this files override
 * ANTLR autogenerated ones.
 * 
 * If the SLICE.g4 is modified, the lexer and parser must be regenerated using ANTLR and the functions in this file might need
 * to be adjusted. For instance, if func_stmt is renamed function_stmt in the g4, the function visitFunc_stmt in this 
 * file must be renamed visitFunction_stmt and the parameter will be SliceParser.Function_stmtContext ctx. If a term has been
 * deleted or added for a rule, the associated function in this file must be updated accordingly.
 * @author delanneevc
 *
 */
public class SliceFacade extends SliceBaseVisitor<Value> {

	private Boolean carbonCentered = null;
	// store variables (there's only one global scope!)
	private Map<String, Value> memory = new HashMap<String, Value>();
	private Map<String, SliceParser.FuncdefContext> functionMemory = new HashMap<String, SliceParser.FuncdefContext>();
	Map<Integer, Boolean> whereConf;
	private int location;
	private Value[][] subjects;
	private Value subject;
	// 0= not setup, 1 = equal, 2=contain, -1=not equal, -2 = not contain
	private int relationType = 0;
	// 1= at least, 2 = at most, 3 = less than, 4 = more than, 5 = less hindered 6 =
	// more hindered, 7 = exactly
	private int operatorType = 0;
	private String mathCompOp = null;
	private int savedArticle = -999;
	private SliceType.Loc atom_loc = null;
	private boolean isItAnd = false;
	private IAtomContainer ac;
	private IAtomContainer implicitHydrogenAc;
	private int rating = 0;
	private boolean kill = false;
	private boolean exit = false;
	private int slighlty = 0;
	private int moderately = 0;
	private int strongly = 0;
	private int severely = 0;
	/**
	 * @param ac
	 */
	public SliceFacade(IAtomContainer ac) {
		super();
		this.ac = ac;
		implicitHydrogenAc = Tools.convertExplicitToImplicitHydrogens(ac);
	}


	public Value visitInstructions(SliceParser.InstructionsContext ctx) {
		// TODO save all parse tree in memory
		List<SliceParser.Compound_stmtContext> compoundList = new ArrayList<>();
		// parse function
		for (SliceParser.StmtContext stmt : ctx.stmt()) {
			if (stmt.compound_stmt() != null) {
				if (stmt.compound_stmt().funcdef() != null) {
					// System.err.println(stmt.compound_stmt().funcdef().getText());
					functionMemory.put(stmt.compound_stmt().funcdef().func_stmt().function_name().getText(),
							stmt.compound_stmt().funcdef());
				}
				// add compound stmt
				else {
					compoundList.add(stmt.compound_stmt());
				}
			} else if (stmt.simple_stmt() != null) {
				for (SliceParser.Small_stmtContext small : stmt.simple_stmt().small_stmt()) {
					if (small.import_stmt() != null) {
						// System.err.println(small.import_stmt().getText());
						visitImport_stmt(small.import_stmt());
					}
					// TODO if needed
					else {
						// visit
						visit(small);
					}
				}
			}
		}
		// System.out.println("fmemory "+functionMemory.keySet());
		for (SliceParser.Compound_stmtContext stmt : compoundList) {
			// visit
			//System.out.println("STMT " + stmt.getText());
			visit(stmt);
			if (kill)
				return new Value(false);
		}
		return new Value(true);
	}


	public Value visitImport_stmt(SliceParser.Import_stmtContext ctx) {
		// System.out.println("visitImport_stmt " + ctx.getText());
		if (ctx.import_from() != null)
			visitImport_from(ctx.import_from());
		else if (ctx.import_module() != null)
			visitImport_module(ctx.import_module());
		return Value.VOID;
	}

	public Value visitImport_module(SliceParser.Import_moduleContext ctx) {
		// System.out.println("visitImport_module " + ctx.getText());
		String path = null;

		for (SliceParser.Import_as_nameContext nameCtx : ctx.import_as_names().import_as_name()) {
			// it's a path
			if (nameCtx.STRING() != null) {
				path = nameCtx.STRING().getText();
			} else if (nameCtx.path() != null) {
				path = nameCtx.path().getText();
			} else {
				try {
					path = new File(".").getCanonicalPath() + separator + nameCtx.NAME().get(0).getText();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			String[] splitedPath = path.split("/");
			String modulePrefix = splitedPath[splitedPath.length - 1];
			try {
				// TODO charger recursivement tous les imports
				SliceLexer sliceLexer = new SliceLexer(CharStreams.fromFileName(path));
				CommonTokenStream commonTokenStream = new CommonTokenStream(sliceLexer);
				SliceParser sliceParser = new SliceParser(commonTokenStream);
				// System.out.println(path.split("/").length);
				if (nameCtx.AS() != null)
					putFunctionsInMemory(sliceParser.instructions(), nameCtx.NAME().get(1).getText());
				else
					putFunctionsInMemory(sliceParser.instructions(), modulePrefix);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				System.err.println("No functions were imported from " + modulePrefix
						+ "\n\t -> check if the import statements are correct");
				System.exit(0);
				e.printStackTrace();
			}

		}
		return Value.VOID;
	}

	public Value visitImport_from(SliceParser.Import_fromContext ctx) {
		// System.out.println("visitImport_from " + ctx.getText());
		String path = null;
		// it's a path
		if (ctx.STRING() != null) {
			path = ctx.STRING().getText();
		} else {
			try {
				path = new File(".").getCanonicalPath() + separator + ctx.NAME().getText();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		Map<String, String> names = new HashMap<String, String>();
		for (SliceParser.Import_as_nameContext nameCtx : ctx.import_as_names().import_as_name()) {
			if (nameCtx.AS() != null)
				names.put(nameCtx.NAME(0).getText(), nameCtx.NAME(1).getText());
			else
				names.put(nameCtx.NAME(0).getText(), null);
		}
		String[] splitedPath = path.split("/");
		String modulePrefix = splitedPath[splitedPath.length - 1];
		try {
			SliceLexer sliceLexer = new SliceLexer(CharStreams.fromFileName(path));
			CommonTokenStream commonTokenStream = new CommonTokenStream(sliceLexer);
			SliceParser sliceParser = new SliceParser(commonTokenStream);
			if (names.isEmpty())
				putFunctionsInMemory(sliceParser.instructions(), modulePrefix);
			else
				putFunctionsInMemory(sliceParser.instructions(), names, modulePrefix);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			System.err.println("No functions were imported from " + modulePrefix
					+ "\n\t -> check if the import statements are correct");
			System.exit(0);
			e.printStackTrace();
		}

		return Value.VOID;
	}

	private void putFunctionsInMemory(SliceParser.InstructionsContext ctx, String modulePrefix) {
		// System.err.println("putFunctionsInMemory " + modulePrefix + " "
		// +ctx.getText());
		// DONE charger variable and visit import by visiting simplesmt
		for (SliceParser.StmtContext stmt : ctx.stmt()) {
			if (stmt.compound_stmt() != null) {
				if (stmt.compound_stmt().funcdef() != null) {
					String name = modulePrefix + "."
							+ stmt.compound_stmt().funcdef().func_stmt().function_name().getText();
					functionMemory.put(name, stmt.compound_stmt().funcdef());
				}
			} else if (stmt.simple_stmt() != null)
				visit(stmt.simple_stmt());
		}
	}

	private void putFunctionsInMemory(SliceParser.InstructionsContext ctx, Map<String, String> names,
			String modulePrefix) {
		for (SliceParser.StmtContext stmt : ctx.stmt()) {
			if (stmt.compound_stmt() != null) {
				if (stmt.compound_stmt().funcdef() != null) {
					String name = stmt.compound_stmt().funcdef().func_stmt().function_name().getText();
					if (names.containsKey(name)) {
						String val = names.get(name);
						if (val == null)
							functionMemory.put(modulePrefix + "." + name, stmt.compound_stmt().funcdef());
						else
							functionMemory.put(modulePrefix + "." + val, stmt.compound_stmt().funcdef());
					}
				}
			}
		}
	}
	
	public Value visitSet(SliceParser.SetContext ctx) {
		String setName = ctx.NAME().getText();
		//System.out.println("line  :"+ctx.PUT().getText()+ " " +ctx.subjects().getText()+ " "+ctx.INTO().getText()+ " "+ctx.NAME().getText());
		//System.out.println("text :"+ctx.NAME().getText());
		//System.out.println("memory put " + memory );
		List<Object> set = new ArrayList<Object>();
		if (memory.containsKey(setName)) {
			set = memory.get(setName).asObjectList();
		}
		
		//Value[][] result = new Value[1][1];
		//System.out.println("before  :"+set);
		Value v = visit(ctx.getChild(1));
		//System.out.println("value type  :"+v.isDoubleArray());
		if(v.isDoubleArray())
		{
			Value[][] result = v.asDoubleArray();
			//System.out.println("result  :"+result);
			for(Value[] or : result)
			{
				for (Value andinor : or)
				{
					if (andinor.isIChemObject()) {
						set.add(andinor.asIChemObject());
					}
					
					else if (andinor.isList() ) {
						set.addAll(andinor.asIChemObjectList());
					}
				}
			}
		}
		else if (v.isList())
		{
			set.addAll(v.asIChemObjectList());
		}
		//set.addAll(Arrays.asList(v));
		//result[0][0]= new Value(set);
		memory.put(setName, new Value(set));
		//System.out.println("after  :"+set);
		System.out.println("memory put " + memory );
		return Value.VOID;
	}

	
	/*public Value visitSet(SliceParser.SetContext ctx) {

        String setName = ctx.NAME().getText();

        List<Object> set = new ArrayList<Object>();

        Value[][] result = new Value[1][1];

        if (memory.containsKey(setName)) {

            set = memory.get(setName).asDoubleArray()[0][0].asObjectList();

        }
        System.out.println("memory put " + memory );
        System.out.println("before  :"+set);
        Value v = visit(ctx.getChild(1));

        set.addAll(v.asObjectList());

        result[0][0] = new Value(set);

        memory.put(setName, new Value(result));
        System.out.println("after  :"+set);
        return Value.VOID;
	}*/
	
	public Value visitRemove_from_set(SliceParser.Remove_from_setContext ctx) {
		String setName = ctx.NAME().getText();
		List<Object> set = new ArrayList<Object>();
		//System.out.println("memoryn remove" + memory );
		if (memory.containsKey(setName)) {
			set = memory.get(setName).asObjectList();
		}
		//System.out.println("before  :"+set);
		Value v = visit(ctx.getChild(1));
		if(v.isDoubleArray())
		{
			Value[][] result = v.asDoubleArray();
			//System.out.println("result  :"+result);
			for(Value[] or : result)
			{
				for (Value andinor : or)
				{
					if (andinor.isIChemObject()) {
						set.remove(andinor.asIChemObject());
					}
					
					else if (andinor.isList() ) {
						set.removeAll(andinor.asIChemObjectList());
					}
				}
			}
		}
		else if (v.isList())
		{
			set.removeAll(v.asIChemObjectList());
		}
	
		memory.put(setName, new Value(set));
		//System.out.println("after  :"+set);
		System.out.println("memory remove" + memory );
		return Value.VOID;
	}
	
	public Value visitEmpty_set(SliceParser.Empty_setContext ctx) {
		//System.out.println("memory empty " + memory );
		String setName = ctx.NAME().getText();
		if (memory.containsKey(setName)) {
			memory.remove(setName);
		}
		System.out.println("memory empty" + memory );
		return Value.VOID;
	}

	private void defineLocation(String text) {
		switch (text) {
		case "anywhere":
			location = SliceConstants.ANYWHERE;
			break;
		case "onpath":
			location = SliceConstants.ONPATH;
			break;
		case "offpath":
			location = SliceConstants.OFFPATH;
			break;
		case "onring":
			location = SliceConstants.ONRING;
			break;
		case "offring":
			location = SliceConstants.OFFRING;
			break;
		case "on the bridge":
			location = SliceConstants.ONTHEBRIDGE;
			break;
		case "off the bridge":
			location = SliceConstants.OFFTHEBRIDGE;
			break;
		case "on the current ring":
			location = SliceConstants.ONTHEBRIDGE;
			break;
		case "off the current ring":
			location = SliceConstants.OFFTHEBRIDGE;
			break;
		default:
			location = SliceConstants.ANYWHERE;
			break;
		}
	}
	public Value visitForeach_stmt(SliceParser.Foreach_stmtContext ctx) {

		SliceParser.Loop_stmtContext loop = ctx.loop_stmt();
		//System.out.println("visitForeach_stmt : "+ctx.getText());
		// whereConf.clear();
		whereConf = initWhereConfig();
		whereConf = setWhereConfig(loop.where_stmt());
		if (loop.where_stmt() != null) {
			defineLocation(loop.where_stmt().getText());
		}
		else {
			location = SliceConstants.ANYWHERE;
		}
		Value predicate = null;
		//System.out.println("loop : "+loop.loop_predicate().variable_name().getText());
		//System.out.println("memory : "+memory);
		List<Object> list = new ArrayList<Object>();
		if (loop.loop_predicate().variable_name() != null) {
			predicate = memory.get(loop.loop_predicate().variable_name().getText());
		}
		//System.out.println(predicate);
		//System.out.println(memory.get(loop.loop_predicate().variable_name().getText()).asObjectList());
		
		
		if (loop.loop_predicate().MOLECULE() != null) {
			IAtomContainer query = predicate == null ? ac : (IAtomContainer) predicate.asIChemObject();
			if (loop.loop_subject().ATOM() != null) {
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						list.add(a);
					}
				}
			} else if (loop.loop_subject().BOND() != null) {
				for (IBond b : query.bonds()) {
					if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
							&& (boolean) b.getEnd().getProperty(location))) {
						list.add(b);
					}
				}
			} else if (loop.loop_subject().RING() != null) {
				SliceSet cs = new SliceSet();
				IRingSet allRings = null;
				try {
					allRings = cs.getAllRing(query);
				} catch (CDKException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				IRingSet newSet = DefaultChemObjectBuilder.getInstance().newInstance(IRingSet.class);
				for (IAtomContainer ac2 : allRings.atomContainers()) {
					if (location == SliceConstants.ANYWHERE || (boolean) ac2.getAtom(0).getProperty(location) == true) {
						list.add(ac2);
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_type() != null) {

				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_type().getStart().getType();
				String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						if (a.getSymbol().equals(type))
							list.add(a);
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_property() != null) {
				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_property().getStart().getType();
				atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token));
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						try {
							if (satom.isProp(prop, a, null, null, query, location)) {
								list.add(a);							}
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_combined() != null) {
				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_combined().atomtype().getStart().getType();
				String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
				int token2 = loop.loop_subject().loop_subject_atom_combined().atom_or_bond_properties().getStart().getType();
				atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token2));
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						try {
							if (satom.isProp(prop, a, null, null, query, location) && a.getSymbol().equals(type)) 
								list.add(a);
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_locs() != null) {
				ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
				SliceParser.Loop_subject_atom_locsContext context = loop.loop_subject().loop_subject_atom_locs();
				List<IChemObject> refs = new ArrayList<IChemObject>();
				if (context.INT() != null) {
					// TODO check if it selcts according to the atom maping
					IAtom ref = (IAtom) sf.getChemObjectByID(query, ChemicalObject.ATOM,
							Integer.parseInt(context.INT().getText()));
					refs.add(ref);
				} else if (context.variable_name() != null) {
					String varName = context.variable_name().getText();
					if (memory.get(varName).isIChemObject()) {
						IAtom ref = (IAtom) memory.get(varName).asIChemObject();
						refs.add(ref);
					}
					else if (memory.get(varName).isList()) {
						refs = memory.get(varName).asIChemObjectList();
					}
					
				} else {
					return Value.VOID;
				}
				for (int i = 0; i < refs.size(); i++) {
					IAtom ref = (IAtom) refs.get(i);
					List<IAtom> locs = new ArrayList<IAtom>();
					int token = context.atom_loc().getStart().getType();
					SliceType.Loc loc = SliceType.Loc.valueOf(getTokenName(token));
					if (context.atomtype() != null) {
						SliceAtom satom = new SliceAtom();
						int token2 = context.atomtype().getStart().getType();
						Elements elt = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token2)));
						if (context.WITHIN() != null) {
							locs = sf.getChemObjectByLocs(query, elt, SliceType.Loc.ALPHA, ref, whereConf);
							if (loc.equals(SliceType.Loc.BETA)) {
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
							} else if (loc.equals(SliceType.Loc.GAMMA)) {
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.GAMMA, ref, whereConf));
							}
						} else {
							locs = sf.getChemObjectByLocs(query, elt, loc, ref, whereConf);
						}
					} else {
						// TODO make separate function for within case
						// TODO incusing explicit hydrogen
						if (context.WITHIN() != null) {
							locs = sf.getChemObjectByLocs(query, SliceType.Loc.ALPHA, ref, whereConf);
							if (loc.equals(SliceType.Loc.BETA)) {
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
							} else if (loc.equals(SliceType.Loc.GAMMA)) {
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.GAMMA, ref, whereConf));
							}
						} else {
							locs = sf.getChemObjectByLocs(query, loc, ref, whereConf);
						}
					}
					List<IAtom> toRemove = new ArrayList<IAtom>();
					// remove explicit hydrogens
					if (context.NOT() != null) {
						for (IAtom a : locs) {
							if (a.getSymbol().equals("H")) {
								toRemove.add(a);
							}
						}
						locs.removeAll(toRemove);
					}
					for (IAtom a : locs) {
						list.add(a);
					}
				}
			} else if (loop.loop_subject().loop_subject_bond_property() != null) {
				SliceBond sbond = new SliceBond();
				int token = loop.loop_subject().loop_subject_bond_property().getStart().getType();
				bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
				for (IBond b : query.bonds()) {
					if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
							&& (boolean) b.getEnd().getProperty(location) == true)) {
						try {
							if (sbond.isProp(prop, b, null, null, query, location))
								list.add(b);
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_group_property().getStart().getType();
				SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getGroup(prop, query));
			} else if (loop.loop_subject().loop_subject_functional_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_functional_group_property().getStart().getType();
				SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getFunctionalGroup(fg, query));
			} else if (loop.loop_subject().loop_subject_non_functional_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_non_functional_group_property().getStart().getType();
				SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getFunctionalGroup(fg, query));
			}
		} else if (loop.loop_predicate().loop_predicate_ring() != null) {
			SliceSet cs = new SliceSet();
			IRingSet allRings = null;
			SliceParser.Loop_predicate_ringContext context = loop.loop_predicate().loop_predicate_ring();
			try {
				allRings = cs.getAllRing(ac);
			} catch (CDKException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			IRingSet newSet = DefaultChemObjectBuilder.getInstance().newInstance(IRingSet.class);
			for (IAtomContainer ac2 : allRings.atomContainers()) {
				boolean keepRing = true;
				if ((boolean) ac2.getAtom(0).getProperty(location) == false) {
					keepRing = false;
				}
				if (context.ALIPHATIC() != null) {
					if (!ac2.getAtom(0).isAromatic()) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				}
				if (context.AROMATIC() != null) {
					if (ac2.getAtom(0).isAromatic()) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				}
				if (context.ring_size() != null) {
					int target = Integer.parseInt(context.INT(0).getText());
					if (context.OR_SMALLER() != null) {
						if (ac2.getAtomCount() <= target) {
							keepRing = true;
						} else {
							keepRing = false;
						}
					} else if (context.OR_LARGER() != null) {
						if (ac2.getAtomCount() >= target) {
							keepRing = true;
						} else {
							keepRing = false;
						}
					} else if (context.THROUGH() != null) {
						if (ac2.getAtomCount() >= target
								&& ac2.getAtomCount() <= Integer.parseInt(context.INT(1).getText())) {
							keepRing = true;
						} else {
							keepRing = false;
						}
					} else {
						if (ac2.getAtomCount() == target) {
							keepRing = true;
						} else {
							keepRing = false;
						}
					}
				}
				if (context.ring_prefix_prop() != null) {
					for (IAtom a : ac2.atoms()) {
						if (context.ring_prefix_prop().CARBOCYCLIC() != null) {
							if (!a.getSymbol().equals("C")) {
								keepRing = false;
								break;
							}
						} else if (context.ring_prefix_prop().HETEROCYCLIC() != null) {
							if (!a.getSymbol().equals("C")) {
								keepRing = true;
								break;
							}
						}
					}
				}
				if (keepRing) {
					newSet.addAtomContainer(ac2);
				}
			}
			for (IAtomContainer query : newSet.atomContainers()) {
				if (loop.loop_subject().ATOM() != null) {
					for (IAtom a : query.atoms()) {
						if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
							list.add(a);
						}
					}
				} else if (loop.loop_subject().BOND() != null) {
					for (IBond b : query.bonds()) {
						if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
								&& (boolean) b.getEnd().getProperty(location))) {
							list.add(b);
						}
					}
				} else if (loop.loop_subject().RING() != null) {
					if (location == SliceConstants.ANYWHERE
							|| (boolean) query.getAtom(0).getProperty(location) == true) {
						list.add(query);
					}
				} else if (loop.loop_subject().loop_subject_atom_type() != null) {
					SliceAtom satom = new SliceAtom();
					int token = loop.loop_subject().loop_subject_atom_type().getStart().getType();
					String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
					for (IAtom a : query.atoms()) {
						if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
							if (a.getSymbol().equals(type))
								list.add(a);
						}
					}
				} else if (loop.loop_subject().loop_subject_atom_property() != null) {
					SliceAtom satom = new SliceAtom();
					int token = loop.loop_subject().loop_subject_atom_property().getStart().getType();
					atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token));
					for (IAtom a : query.atoms()) {
						if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
							try {
								if (satom.isProp(prop, a, null, null, query, location))
									list.add(a);
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					}
				} else if (loop.loop_subject().loop_subject_atom_combined() != null) {
					SliceAtom satom = new SliceAtom();
					int token = loop.loop_subject().loop_subject_atom_type().getStart().getType();
					String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
					int token2 = loop.loop_subject().loop_subject_atom_property().getStart().getType();
					atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token2));
					for (IAtom a : query.atoms()) {
						if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
							try {
								if (satom.isProp(prop, a, null, null, query, location) && a.getSymbol().equals(type))
									list.add(a);
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					}
				} else if (loop.loop_subject().loop_subject_atom_locs() != null) {
					ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
					SliceParser.Loop_subject_atom_locsContext context1 = loop.loop_subject().loop_subject_atom_locs();
					List<IChemObject> refs = new ArrayList<IChemObject>();
					if (context1.INT() != null) {
						// TODO check if it selcts according to the atom maping
						IAtom ref = (IAtom) sf.getChemObjectByID(query, ChemicalObject.ATOM,
								Integer.parseInt(context1.INT().getText()));
						refs.add(ref);
					} else if (context1.variable_name() != null) {
						String varName = context1.variable_name().getText();
						if (memory.get(varName).isIChemObject()) {
							IAtom ref = (IAtom) memory.get(varName).asIChemObject();
							refs.add(ref);
						}
						else if (memory.get(varName).isList()) {
							refs = memory.get(varName).asIChemObjectList();
						}
						
					} else {
						return Value.VOID;
					}
					
					for (int i = 0; i < refs.size(); i++) {
						IAtom ref = (IAtom) refs.get(i);
						List<IAtom> locs = new ArrayList<IAtom>();
						int token = context1.atom_loc().getStart().getType();
						SliceType.Loc loc = SliceType.Loc.valueOf(getTokenName(token));
						if (context1.atomtype() != null) {
							SliceAtom satom = new SliceAtom();
							int token2 = context1.atomtype().getStart().getType();
							Elements elt = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token2)));
							if (context1.WITHIN() != null) {
								locs = sf.getChemObjectByLocs(query, elt, SliceType.Loc.ALPHA, ref, whereConf);
								if (loc.equals(SliceType.Loc.BETA)) {
									locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
								} else if (loc.equals(SliceType.Loc.GAMMA)) {
									locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
									locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.GAMMA, ref, whereConf));
								}
							} else {
								locs = sf.getChemObjectByLocs(query, elt, loc, ref, whereConf);
							}
						} else {
							// TODO make separate function for within case
							// TODO incusing explicit hydrogen
							if (context1.WITHIN() != null) {
								locs = sf.getChemObjectByLocs(query, SliceType.Loc.ALPHA, ref, whereConf);
								if (loc.equals(SliceType.Loc.BETA)) {
									locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
								} else if (loc.equals(SliceType.Loc.GAMMA)) {
									locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
									locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.GAMMA, ref, whereConf));
								}
							} else {
								locs = sf.getChemObjectByLocs(query, loc, ref, whereConf);
							}
						}
						List<IAtom> toRemove = new ArrayList<IAtom>();
						// remove explicit hydrogens
						if (context1.NOT() != null) {
							for (IAtom a : locs) {
								if (a.getSymbol().equals("H")) {
									toRemove.add(a);
								}
							}
							locs.removeAll(toRemove);
						}
						for (IAtom a : locs) {
							list.add(a);
						}
					}
				} else if (loop.loop_subject().loop_subject_bond_property() != null) {
					SliceBond sbond = new SliceBond();
					int token = loop.loop_subject().loop_subject_bond_property().getStart().getType();
					bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
					for (IBond b : query.bonds()) {
						if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
								&& (boolean) b.getEnd().getProperty(location) == true)) {
							try {
								if (sbond.isProp(prop, b, null, null, query, location))
									list.add(b);
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					}
				} else if (loop.loop_subject().loop_subject_group_property() != null) {
					SliceGroup sgroup = new SliceGroup();
					int token = loop.loop_subject().loop_subject_group_property().getStart().getType();
					SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));
					// TODO add all group type by getting the equivalent sub atomcontainer
					// list.addAll(sgroup.getGroup(prop, query));
				} else if (loop.loop_subject().loop_subject_functional_group_property() != null) {
					SliceGroup sgroup = new SliceGroup();
					int token = loop.loop_subject().loop_subject_functional_group_property().getStart().getType();
					SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
					// TODO add all group type by getting the equivalent sub atomcontainer
					// list.addAll(sgroup.getFunctionalGroup(fg, query));
				} else if (loop.loop_subject().loop_subject_non_functional_group_property() != null) {
					SliceGroup sgroup = new SliceGroup();
					int token = loop.loop_subject().loop_subject_non_functional_group_property().getStart().getType();
					SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
					// TODO add all group type by getting the equivalent sub atomcontainer
					// list.addAll(sgroup.getFunctionalGroup(fg, query));
				}
			}
		} else if (loop.loop_predicate().variable_name() != null) {
			List<Object> list_variable = new ArrayList<Object>();
			Value variable = memory.get(loop.loop_predicate().variable_name().getText());
			IAtomContainer query = ac;
			if (loop.loop_subject().ATOM() != null) {
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						list_variable.add(a);
					}
				}
			} else if (loop.loop_subject().BOND() != null) {
				for (IBond b : query.bonds()) {
					if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
							&& (boolean) b.getEnd().getProperty(location))) {
						list_variable.add(b);
					}
				}
			} else if (loop.loop_subject().RING() != null) {
				SliceSet cs = new SliceSet();
				IRingSet allRings = null;
				try {
					allRings = cs.getAllRing(query);
				} catch (CDKException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				IRingSet newSet = DefaultChemObjectBuilder.getInstance().newInstance(IRingSet.class);
				for (IAtomContainer ac2 : allRings.atomContainers()) {
					if (location == SliceConstants.ANYWHERE || (boolean) ac2.getAtom(0).getProperty(location) == true) {
						list_variable.add(ac2);
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_type() != null) {

				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_type().getStart().getType();
				String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						if (a.getSymbol().equals(type))
							list_variable.add(a);
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_property() != null) {
				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_property().getStart().getType();
				atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token));
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						try {
							if (satom.isProp(prop, a, null, null, query, location)) {
								list_variable.add(a);							}
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_combined() != null) {
				SliceAtom satom = new SliceAtom();
				int token = loop.loop_subject().loop_subject_atom_combined().atomtype().getStart().getType();
				String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
				int token2 = loop.loop_subject().loop_subject_atom_combined().atom_or_bond_properties().getStart().getType();
				atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token2));
				for (IAtom a : query.atoms()) {
					if (location == SliceConstants.ANYWHERE || (boolean) a.getProperty(location) == true) {
						try {
							if (satom.isProp(prop, a, null, null, query, location) && a.getSymbol().equals(type)) 
								list_variable.add(a);
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_atom_locs() != null) {
				ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
				SliceParser.Loop_subject_atom_locsContext context = loop.loop_subject().loop_subject_atom_locs();
				List<IChemObject> refs = new ArrayList<IChemObject>();
				if (context.INT() != null) {
					// TODO check if it selcts according to the atom maping
					IAtom ref = (IAtom) sf.getChemObjectByID(query, ChemicalObject.ATOM,
							Integer.parseInt(context.INT().getText()));
					refs.add(ref);
				} else if (context.variable_name() != null) {
					String varName = context.variable_name().getText();
					if (memory.get(varName).isIChemObject()) {
						IAtom ref = (IAtom) memory.get(varName).asIChemObject();
						refs.add(ref);
					}
					else if (memory.get(varName).isList()) {
						refs = memory.get(varName).asIChemObjectList();
					}
					
				} else {
					return Value.VOID;
				}
				for (int i = 0; i < refs.size(); i++) {
					IAtom ref = (IAtom) refs.get(i);
					List<IAtom> locs = new ArrayList<IAtom>();
					int token = context.atom_loc().getStart().getType();
					SliceType.Loc loc = SliceType.Loc.valueOf(getTokenName(token));
					if (context.atomtype() != null) {
						SliceAtom satom = new SliceAtom();
						int token2 = context.atomtype().getStart().getType();
						Elements elt = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token2)));
						if (context.WITHIN() != null) {
							locs = sf.getChemObjectByLocs(query, elt, SliceType.Loc.ALPHA, ref, whereConf);
							if (loc.equals(SliceType.Loc.BETA)) {
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
							} else if (loc.equals(SliceType.Loc.GAMMA)) {
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.BETA, ref, whereConf));
								locs.addAll(sf.getChemObjectByLocs(query, elt, SliceType.Loc.GAMMA, ref, whereConf));
							}
						} else {
							locs = sf.getChemObjectByLocs(query, elt, loc, ref, whereConf);
						}
					} else {
						// TODO make separate function for within case
						// TODO incusing explicit hydrogen
						if (context.WITHIN() != null) {
							locs = sf.getChemObjectByLocs(query, SliceType.Loc.ALPHA, ref, whereConf);
							if (loc.equals(SliceType.Loc.BETA)) {
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
							} else if (loc.equals(SliceType.Loc.GAMMA)) {
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.BETA, ref, whereConf));
								locs.addAll(sf.getChemObjectByLocs(query, SliceType.Loc.GAMMA, ref, whereConf));
							}
						} else {
							locs = sf.getChemObjectByLocs(query, loc, ref, whereConf);
						}
					}
					List<IAtom> toRemove = new ArrayList<IAtom>();
					// remove explicit hydrogens
					if (context.NOT() != null) {
						for (IAtom a : locs) {
							if (a.getSymbol().equals("H")) {
								toRemove.add(a);
							}
						}
						locs.removeAll(toRemove);
					}
					for (IAtom a : locs) {
						list_variable.add(a);
					}
				}
			} else if (loop.loop_subject().loop_subject_bond_property() != null) {
				SliceBond sbond = new SliceBond();
				int token = loop.loop_subject().loop_subject_bond_property().getStart().getType();
				bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
				for (IBond b : query.bonds()) {
					if (location == SliceConstants.ANYWHERE || ((boolean) b.getBegin().getProperty(location) == true
							&& (boolean) b.getEnd().getProperty(location) == true)) {
						try {
							if (sbond.isProp(prop, b, null, null, query, location))
								list_variable.add(b);
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			} else if (loop.loop_subject().loop_subject_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_group_property().getStart().getType();
				SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getGroup(prop, query));
			} else if (loop.loop_subject().loop_subject_functional_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_functional_group_property().getStart().getType();
				SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getFunctionalGroup(fg, query));
			} else if (loop.loop_subject().loop_subject_non_functional_group_property() != null) {
				SliceGroup sgroup = new SliceGroup();
				int token = loop.loop_subject().loop_subject_non_functional_group_property().getStart().getType();
				SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
				// TODO add all group type by getting the equivalent sub atomcontainer
				// list.addAll(sgroup.getFunctionalGroup(fg, query));
			}
			
			//stefi
			if(variable.isList())
			{
				
				//System.out.println("islist :");
				/*List<Object> list2 = variable.asObjectList();
				for(Object obj : list2)
				{
					if(obj instanceof Value)
					{
						System.out.println("obj :"+obj);
						if(((Value) obj).isIChemObject())
						{
							System.out.println("obj ichem");
							list.add(((Value)obj).asIChemObject());
						}
						else if(((Value) obj).isList())
						{
							System.out.println("islist");
							List<Object> list3 = ((Value)obj).asObjectList();
							for(Object obj2 : list3)
							{
								if(((Value) obj2).isIChemObject())
								{
									System.out.println("is list obj :");
									list.add(((Value)obj2).asIChemObject());
								}
							}
						}
					}
				}*/
				for(Object obj : list_variable) {
					if(variable.asObjectList().contains(obj)) {
						if(!list.contains(obj))
							list.add(obj);
					}
				}
				//list.addAll(variable.asObjectList());
			}
			//list.addAll(Arrays.asList( memory.get(loop.loop_predicate().variable_name().getText())));	
		}
		else if(loop.loop_predicate().set_current_ring() != null){
			Value v = visit(loop.loop_predicate().set_current_ring());
			if(v.isList()){
				list.addAll(v.asObjectList());
			}
			//SliceParser.Set_current_ringContext ringcontext = loop.loop_predicate().set_current_ring();
		}
		/*System.out.println("element list :" +list.size()+" "+ list);
		for (Object obj : list) {
			System.out.println(((IAtom)obj).getSymbol()+((IAtom)obj).getIndex() + " aromatic :"+((IAtom)obj).isAromatic());
		}

		System.out.println("var_name: "+ loop.var().variable_name().getText());*/
		for (Object obj : list) {
			if (obj instanceof IChemObject) {
				List<IChemObject> temp = new ArrayList<IChemObject>();
				temp.add((IChemObject) obj);
				memory.put(loop.var().variable_name().getText(), new Value(temp));
			}
			else if (obj instanceof Double) {
				memory.put(loop.var().variable_name().getText(), new Value((Double) obj));
			}
			else if (obj instanceof Boolean) {
				memory.put(loop.var().variable_name().getText(), new Value((Boolean) obj));
			}
			else if (obj instanceof List) {
				memory.put(loop.var().variable_name().getText(), new Value((List) obj));
			}
			else
			{
				System.out.println("error:" + obj.getClass());
			}
			for (SliceParser.StmtContext stmt : ctx.block().suite().stmt()) {
				visitStmt(stmt);
				if (exit) {
					exit = false;
					return Value.VOID;
				}
				if (kill)
					return Value.VOID;
			}
		}
		
		return Value.VOID;
	}

	public Value visitStmt(SliceParser.StmtContext ctx) {
		//System.out.println("visitStmt "+ctx.getText());
		if (ctx.simple_stmt() != null) {
			for (SliceParser.Small_stmtContext small : ctx.simple_stmt().small_stmt()) {
				visit(small);
				if (exit) {
					exit = false;
					return Value.VOID;
				}
				if (kill)
					return Value.VOID;
			}
		} else if (ctx.compound_stmt() != null)
			return visitCompound_stmtContext(ctx.compound_stmt());
		return Value.VOID;
	}

	public Value visitExpr_stmt(SliceParser.Expr_stmtContext ctx) {
		//System.out.println("visitExpr_stmt "+ctx.getText());
		String varname = ctx.variable_name().getText();
		Value var = null;
		if (memory.containsKey(varname)) {
			var = memory.get(varname);
		}

		String augassign = null;
		if (ctx.PLUS() != null) {
			augassign = "+";
		} else if (ctx.MINUS() != null) {
			augassign = "-";
		} else if (ctx.TIMES() != null) {
			augassign = "*";
		} else if (ctx.DIV() != null) {
			augassign = "/";
		} else if (ctx.MODULUS() != null) {
			augassign = "%";
		} else if (ctx.EQUAL() != null) {
			augassign = "=";
		}

		if (augassign != null) {
			if (augassign.equals("=")) {
				Value result = visit(ctx.value());
				memory.put(varname, result);
			} else {
				double result = 0;
				double value2 = var != null ? var.asDouble() : 0;
				if (ctx.value().numeric_num() != null) {
					value2 += Double.parseDouble(ctx.value().numeric_num().getText());
				} else if (ctx.value().variable_name() != null) {
					value2 += memory.get(ctx.value().variable_name().getText()).asDouble();
				}
				switch (augassign) {
				case "+":
					result += value2;
					break;
				case "-":
					result -= value2;
					break;
				case "*":
					result *= value2;
					break;
				case "/":
					result /= value2;
					break;
				case "%":
					result %= value2;
					break;
					/*
					 * case "&=": value &= value2; case "|=": value |= value2; case "^=": value ^=
					 * value2; case "<<=": value <<= value2; case ">>=": value >>= value2; case
					 * "**=": value **= value2; case "//=": value //= value2;
					 */ 
				}
				memory.put(varname, new Value(result));
			}
		}
		// it's equal
		else {
			if (ctx.value().bool() != null) {
				memory.put(varname, new Value(Boolean.parseBoolean(ctx.value().bool().getText())));
			} else if (ctx.value().numeric_num() != null) {
				memory.put(varname, new Value(Double.parseDouble(ctx.value().numeric_num().getText())));
			} else if (ctx.value().variable_name() != null) {
				memory.put(varname, memory.get(ctx.value().variable_name().getText()));
			} else if (ctx.value().subjects() != null) {
				memory.put(varname, visit(ctx.value().subjects()));
			}
		}
		return Value.VOID;
	}

	public Value visitTerm(SliceParser.TermContext ctx) {

		//System.out.println("visitTerm: "+ ctx.getText()+ ctx.term_block());
		if (ctx.term_block() != null) {
			// comparison between numerical value
			//System.out.println(ctx.atom1().variable_name().getText()+ "v1: "+v1);
			//System.out.println(" here we are "+ctx.term_block().relation());
			if (ctx.term_block().relation() == null) {
				location = SliceConstants.ANYWHERE;
				// whereConf.clear();
				whereConf = initWhereConfig();
				initMathOp(ctx.term_block().math_comp_op());
				Value v1, v2;
				if (ctx.term_block().atom1().variable_name() != null) {
					v1 = memory.get(ctx.term_block().atom1().variable_name().getText());
				}
				else {
					v1 = visit(ctx.term_block().atom1());
				}
				SliceParser.Atom2Context atom2 = ctx.term_block().atom2();
				if (atom2.variable_name() != null) {
					v2 = memory.get(atom2.variable_name().getText());
				}
				else if (atom2.alpha_num() != null) {
					v2 = new Value(alphaNumToNum(atom2.alpha_num().getText()));
				}
				else if (atom2.numeric_num() != null) {
					v2 = new Value(Double.parseDouble(atom2.numeric_num().getText()));
				}
				else if (atom2.bool() != null) {
					v2 = new Value(Boolean.parseBoolean(atom2.bool().getText()));
				}
				else if (atom2.STRING() != null) {
					v2 = new Value(atom2.STRING().getText());
				}
				else {
					v2 = visit(atom2);
				}
				if (v1.isDouble() && v2.isDouble())
					return comparison(v1.asDouble(), v2.asDouble(), mathCompOp);
				else if (v1.isBoolean() && v2.isBoolean() && ctx.term_block().math_comp_op().EQUAL() != null) {
					return new Value(v1.asBoolean() == v2.asBoolean());
				} else if (v1.isBoolean() && v2.isBoolean() && ctx.term_block().math_comp_op().NE() != null) {
					return new Value(v1.asBoolean() != v2.asBoolean());
				}
			} else {
				mathCompOp = null;
				// whereConf.clear();
				whereConf = initWhereConfig();
				if (ctx.where_stmt() != null) {
					defineLocation(ctx.term_block().where_stmt().getText());
					whereConf = setWhereConfig(ctx.term_block().where_stmt());
				} else
					location = SliceConstants.ANYWHERE;

				if (ctx.term_block().relation() != null) {
					if (ctx.term_block().relation().pos_relation() != null) {
						if (ctx.term_block().relation().pos_relation().equal() != null) {
							relationType = 1;
						} else if (ctx.term_block().relation().pos_relation().contain() != null) {
							relationType = 2;
						}
					}
					else if (ctx.term_block().relation().neg_relation() != null) {
						if (ctx.term_block().relation().neg_relation().notequal() != null) {
							relationType = -1;
						} else if (ctx.term_block().relation().neg_relation().notcontain() != null) {
							relationType = -2;
						}
					} 
				}
				Value v1,v2;
				if (ctx.atom1().variable_name() != null) {
					v1 = memory.get(ctx.term_block().atom1().variable_name().getText());
				}
				else if (ctx.term_block().atom1().subjects() != null) {
					subjects = visit(ctx.term_block().atom1().subjects()).asDoubleArray();
				} else {
					v1 = visit(ctx.term_block().atom1());
				}
			
				v2 = visit(ctx.term_block().atom2());
				return v2;
			}

		} else {
			// comparison between numerical value
			if (ctx.relation() == null) {
				location = SliceConstants.ANYWHERE;
				// whereConf.clear();
				whereConf = initWhereConfig();
				initMathOp(ctx.math_comp_op());
				Value v1, v2;
				if (ctx.atom1().variable_name() != null) {
					
					v1 = memory.get(ctx.atom1().variable_name().getText());
					Value[][] result = new Value[1][1];
					result[0][0] = memory.get(ctx.atom1().variable_name().getText());
					subjects = result;

				}
				else {
					v1 = visit(ctx.atom1());
				}
				SliceParser.Atom2Context atom2 = ctx.atom2();
				if (atom2.variable_name() != null) {
					v2 = memory.get(atom2.variable_name().getText());
				}
				else if (atom2.alpha_num() != null) {
					v2 = new Value(alphaNumToNum(atom2.alpha_num().getText()));
				}
				else if (atom2.numeric_num() != null) {
					v2 = new Value(Double.parseDouble(atom2.numeric_num().getText()));
				}
				else if (atom2.bool() != null) {
					v2 = new Value(Boolean.parseBoolean(atom2.bool().getText()));
				}
				else if (atom2.STRING() != null) {
					v2 = new Value(atom2.STRING().getText());
				}
				else {
					v2 = visit(atom2);
				}
				if (v1.isDouble() && v2.isDouble())
					return comparison(v1.asDouble(), v2.asDouble(), mathCompOp);
				else if (v1.isBoolean() && v2.isBoolean() && ctx.math_comp_op().EQUAL() != null) {
					return new Value(v1.asBoolean() == v2.asBoolean());
				} else if (v1.isBoolean() && v2.isBoolean() && ctx.math_comp_op().NE() != null) {
					return new Value(v1.asBoolean() != v2.asBoolean());
				}
				else if(v2.isBoolean()) {
					if(ctx.math_comp_op().EQUAL() != null && v2.asBoolean())
						return new Value(v2.asBoolean());
					else if (ctx.math_comp_op().NE() != null){
						return new Value(!v2.asBoolean());
					}
				}
			} else {
				mathCompOp = null;
				// whereConf.clear();
				whereConf = initWhereConfig();
				if (ctx.where_stmt() != null) {
					defineLocation(ctx.where_stmt().getText());
					whereConf = setWhereConfig(ctx.where_stmt());
				} else
				{
					location = SliceConstants.ANYWHERE;
					whereConf = initWhereConfig();
				}
				if (ctx.relation() != null) {
					if (ctx.relation().pos_relation() != null) {
						if (ctx.relation().pos_relation().equal() != null) {
							relationType = 1;
						} else if (ctx.relation().pos_relation().contain() != null) {
							relationType = 2;
						}
					}
					else if (ctx.relation().neg_relation() != null) {
						if (ctx.relation().neg_relation().notequal() != null) {
							relationType = -1;
						} else if (ctx.relation().neg_relation().notcontain() != null) {
							relationType = -2;
						}
					} 
				}
				if (ctx.term_block() != null) {
					if (ctx.term_block().relation() != null) {
						if (ctx.term_block().relation().pos_relation() != null) {
							if (ctx.term_block().relation().pos_relation().equal() != null) {
								relationType = 1;
							} else if (ctx.term_block().relation().pos_relation().contain() != null) {
								relationType = 2;
							}
						}
						else if (ctx.term_block().relation().neg_relation() != null) {
							if (ctx.term_block().relation().neg_relation().notequal() != null) {
								relationType = -1;
							} else if (ctx.term_block().relation().neg_relation().notcontain() != null) {
								relationType = -2;
							}
						} 
					}
				}
				
				Value v1,v2;
				if (ctx.atom1().variable_name() != null) {
					//System.out.println("memory");
					//convert into array as subject must be a dual entry array. A variable doesn't have and / or constraints
					Value[][] result = new Value[1][1];
					result[0][0] = memory.get(ctx.atom1().variable_name().getText());
					//System.out.println("result"+ result[0][0]+ "text "+ctx.atom1().variable_name().getText());
					subjects = result;
				}
				else if (ctx.atom1().subjects() != null) {
					//System.out.println("double array");
					//System.out.println("sub before :"+subjects);
					//if(subjects !=null)
						//System.out.println("sub length :"+subjects.length);
					subjects = visit(ctx.atom1().subjects()).asDoubleArray();
					//System.out.println("sub after :"+subjects.length);
				} else {
					//System.out.println("atom1");
					v1 = visit(ctx.atom1());
				}
				
				v2 = visit(ctx.atom2());
				return v2;
			}
		}
		return new Value(true);
	}
	
	private void initMathOp(SliceParser.Math_comp_opContext math) {
		if (math.EQUAL() != null) {
			mathCompOp = "EQUAL";
		}
		else if (math.LT() != null) {
			mathCompOp = "LT";
		}
		else if (math.LE() != null) {
			mathCompOp = "LE";
		}
		else if (math.GT() != null) {
			mathCompOp = "GT";
		}
		else if (math.GE() != null) {
			mathCompOp = "GE";
		}
		else if (math.NE() != null) {
			mathCompOp = "NE";
		}
		else {
			mathCompOp = null;
		}
	}

	private Value comparison(Double double1, Double double2, String operator) {
		switch (operator) {
		case "LT":
			return new Value(Double.compare(double1, double2) < 0 ? true : false);
		case "LE":
			new Value(Double.compare(double1, double2) <= 0 ? true : false);
		case "GT":
			return  new Value(Double.compare(double1, double2) > 0 ? true : false);
		case "GE":
			new Value(Double.compare(double1, double2) >= 0 ? true : false);
		case "EQUAL":
			return new Value(Double.compare(double1, double2) == 0 ? true : false);
		case "NE":
			return new Value(Double.compare(double1, double2) != 0 ? true : false);
		}
		return Value.VOID;
	}

	public Value visitFuncStmt(SliceParser.Func_stmtContext ctx) {
		// System.out.println("visitFuncStmt "+ctx.getText() + " " +
		// ctx.function_name().getText() + " " + ctx.parameters().getText());
		// System.out.println(functionMemory.keySet());
		// get tree of function

		// retrieve function previously added in memory
		SliceParser.FuncdefContext funcTree = null;
		String currentName = ctx.function_name().getText();
		for (Entry<String, SliceParser.FuncdefContext> entry : functionMemory.entrySet()) {
			String name = entry.getKey();
			if (name.contains(currentName)) {
				funcTree = entry.getValue();
				break;
			}
		}

		// get names of parameters defined in function ex myFun(p1,p2) names are p1 and
		// p2
		List<String> parameterNames = new ArrayList<String>();
		if (funcTree.func_stmt().parameters().fplist() != null) {
			for (SliceParser.FpdefContext fpdefCtx : funcTree.func_stmt().parameters().fplist().fpdef()) {
				parameterNames.add(fpdefCtx.getText());
			}
		}

		// put parameter values in memory
		if (ctx.parameters().fplist() != null) {
			SliceParser.FplistContext fpList = ctx.parameters().fplist();
			for (int i = 0; i < fpList.fpdef().size(); i++) {
				SliceParser.FpdefContext fdCtx = fpList.fpdef(i);
				// System.out.println(visit(fdCtx).isList());
				memory.put(parameterNames.get(i), (visit(fdCtx)));
			}
		}
		return visit(funcTree.block());
	}

	public Value visitReturn_stmt(SliceParser.Return_stmtContext ctx) {
		// System.out.println("visitReturn_stmt "+ctx.getText() + ctx.bool().getText() +
		// ctx.var());
		String varName1 = null;
		if (ctx.variable_name() != null) {
			// TODO correct BUG when parsing car return an empty list of var
			Value ret = memory.get(memory.get(ctx.variable_name(0).getText()));
			return ret;
		} else if (ctx.numeric_num() != null) {
			Value ret = new Value(Double.parseDouble(ctx.numeric_num().getText()));
			if (ctx.EQ() != null)
				memory.put(varName1, ret);
			return ret;
		} else if (ctx.alpha_num() != null) {
			int token = ctx.alpha_num().getStart().getType();
			Value ret = new Value(alphaNumToNum(getTokenName(token)));
			if (ctx.EQ() != null)
				memory.put(varName1, ret);
			return ret;
		} else if (ctx.bool() != null) {
			int token = ctx.bool().getStart().getType();
			Value ret = new Value(Boolean.valueOf(getTokenName(token)));
			if (ctx.EQ() != null)
				memory.put(varName1, ret);
			return ret;
		}
		return Value.VOID;
	}

	public Value visitRating_stmt(SliceParser.Rating_stmtContext ctx) {
		//System.err.println("visitRating_stmt "+ctx.getText());
		//System.out.println("rating before :"+ rating);
		if (ctx.ADD() != null)
			rating += Integer.parseInt(ctx.INT().getText());
		else if (ctx.SUBTRACT() != null)
			rating -= Integer.parseInt(ctx.INT().getText());
		else if (ctx.qualitative_rating() != null) {
			SliceParser.RatingContext rCtx = ctx.qualitative_rating().rating();
			int rate = 0;
			if (rCtx.SLIGHTLY() != null) {
				rate = 5;
				if (ctx.qualitative_rating().LOWER() != null) slighlty++;
			} else if (rCtx.MODERATELY() != null) {
				rate = 15;
				if (ctx.qualitative_rating().LOWER() != null) moderately++;
			} else if (rCtx.STRONGLY() != null) {
				rate = 30;
				if (ctx.qualitative_rating().LOWER() != null) strongly++;
			} else if (rCtx.SEVERELY() != null) {
				rate = 50;
				if (ctx.qualitative_rating().LOWER() != null) severely++;
			}
			if (ctx.qualitative_rating().LOWER() != null) {
				rating -= rate;
			} else if (ctx.qualitative_rating().RAISE() != null) {
				rating += rate;
			}
		} else
			System.err.println("visitRating_stmt: unmanaged rating");
		//System.out.println("slightly : "+slighlty + " moderately :"+moderately + "strongly : "+strongly +" severely : "+severely );
		//System.out.println("rating after :"+ rating);
		return Value.VOID;
	}

	public Value visitExit_stmt(SliceParser.Exit_stmtContext ctx) {
		// System.out.println("visitExit_stmt "+ctx.getText());
		exit = true;
		return Value.VOID;
	}

	public Value visitKill_stmt(SliceParser.Kill_stmtContext ctx) {
		// System.out.println("visitKill_stmt "+ctx.getText());
		kill = true;
		return Value.VOID;
	}

	public Value visitCompound_stmtContext(SliceParser.Compound_stmtContext ctx) {
		// System.out.println("visitCompound_stmtContext "+ctx.getText());
		if (ctx.foreach_stmt() != null)
			return visitForeach_stmt(ctx.foreach_stmt());
		else
			return visitIf_stmt(ctx.if_stmt());
	}

	public Value visitVariable_name(SliceParser.Variable_nameContext ctx) {
		return memory.get(ctx.getText());
	}

	public Value visitBool(SliceParser.BoolContext ctx) {
		return new Value(Boolean.parseBoolean(ctx.getText()));
	}

	public Value visitNumeric_num(SliceParser.Numeric_numContext ctx) {
		if (ctx.INT() != null) {
			return new Value(Double.parseDouble(ctx.INT().getText()));
		} else {
			return new Value(Double.parseDouble(ctx.DECIMAL().getText()));
		}
	}
	
	public Value visitIf_stmt(SliceParser.If_stmtContext ctx) {
		//System.out.println("visitIf_stmt "+ctx.getText());
		
		Value toReturn = Value.VOID;
		int totalElt = ctx.getChildCount();
		for (int i = 0; i < totalElt; i++) {
			String elt = ctx.getChild(i).getText();
			if (elt.equals("if") || elt.equals("else if")) {
				SliceParser.TestContext test = (TestContext) ctx.getChild(i+1);
				Value result = visit(test);
				/*if(elt.equals("if"))
					System.out.println("===>"+result.asBoolean());
				else
					{
					System.out.println(ctx.getChild(i+1).getText());
					System.out.println("=>"+result.asBoolean());
					}*/
				if (result.asBoolean() == true) {
					//System.out.println("   => "+ctx.getChild(i+3).getText());
					toReturn = visit(ctx.getChild(i+3));
					if (exit) {
						exit = false;
						return Value.VOID;
					}
					if (kill)
						return Value.VOID;
					i+=2;
					break;
				}
				i++;
			}
			if (elt.equals("else")) {
				//System.out.println("==> "+ctx.getChild(i+1).getText());
				toReturn = visit(ctx.getChild(i+1));
				i++;
			}
		}
		return toReturn;
	}

	public Value visitTest(SliceParser.TestContext ctx) {
		//System.out.println("visitTest "+ctx.getText());
		Value res = visitOrTest(ctx.or_test());
		return res;
	}

	public Value visitOrTest(SliceParser.Or_testContext ctx) {
		// System.out.println("visitOrTest "+ctx.getText());
		List<SliceParser.And_testContext> andTests = new ArrayList<SliceParser.And_testContext>(ctx.and_test());
		for (SliceParser.And_testContext andTest : andTests) {
			Value res = visitAndTest(andTest);
			if (res.asBoolean() == true)
				return new Value(true);
		}
		return new Value(false);
	}

	public Value visitAndTest(SliceParser.And_testContext ctx) {
		//System.out.println("visitAndTest "+ctx.getText());
		List<SliceParser.Test_stmtContext> tests = new ArrayList<SliceParser.Test_stmtContext>(ctx.test_stmt());
		if (ctx.test_block().size() > 0) {
			for (SliceParser.Test_blockContext testBlock : ctx.test_block()) {
				tests.add(testBlock.test_stmt());
			}
		}
		for (SliceParser.Test_stmtContext test : tests) {
			Value res = visit(test);
			// reset relationType and subject to question
			relationType = 0;
			subject = null;
			if (res.asBoolean() == false)
				return new Value(false);
		}
		return new Value(true);
	}

	public Value visitOr_subject(SliceParser.Or_subjectContext ctx) {
		//System.out.println("visitOr_select "+ctx.getText());
		List<SliceParser.And_subjectContext> andSubjects = new ArrayList<SliceParser.And_subjectContext>(
				ctx.and_subject());
		int size = andSubjects.size();
		Value[][] result = new Value[size][];
		for (int i = 0; i < size ; i++) {
			//System.out.println("andsubject"+ " "+i+ andSubjects.get(i).getText());
			Value[] andSubj =  visitAnd_subject(andSubjects.get(i)).asArray();
			if (isItAnd){
				result[i] = andSubj;
			}
			else {
				if (andSubj.length == 1 && andSubj[0].isDouble()){
					Value[] res = new Value[1];
					res[0] = new Value(andSubj[0]);
					result[i]= res;
				}
				else {
					if (andSubj.length == 1 && (andSubj[0].asIChemObjectList().size() == 1 || andSubj[0].asIChemObjectList().size() == 0)) {
						result[i] = andSubj;
					}
					else {
						for (int j = 0; j < andSubj.length; j++) {
							List<IChemObject> list = andSubj[j].asIChemObjectList();
							
							//add new OR entries
							
							size += list.size()-1;
							Value[][] copy = new Value[size][];
							System.arraycopy(result, 0, copy, 0, result.length);
							result = copy;
							for (int k = 0; k < list.size(); k++) {
								List<IChemObject> list2 = new ArrayList<IChemObject>();
								list2.add((IChemObject) list.get(k));
								Value[] res2 = new Value[1];
								res2[0] = new Value(list2);
								result[i] = res2;
								i++;
							}
							
						}
					}
				}
				//old code for managing alpha beta gamma, which must be considered as OR
				/*List<IChemObject> list = andSubj[0].asIChemObjectList();
				if (list.size() == 1 || list.size() == 0) {
					result[i] = andSubj;
				}
				else {
					//add new OR entries
					size += andSubj.length;
					Value[][] copy = new Value[size][];
					System.arraycopy(result, 0, copy, 0, result.length);
					result = copy;
					System.out.println(list.size());
					for (int j = 0; j < list.size(); j++) {
						Value[] res2 = new Value[1];
						List<IChemObject> list2 = new ArrayList<IChemObject>();
						list2.add((IChemObject) list.get(j));
						res2[0] = new Value(list2);
						result[i] = res2;
						i++;
					}
				}*/
			}
		}
		/*
		 * if (andSubjects.size() > 1) { Value res = Value.VOID; Value res1 =
		 * visitAnd_subject(andSubjects.get(i)); for (int i = 1; i < andSubjects.size();
		 * i++) { Value res2 = visitAnd_subject(andSubjects.get(i)); res = new
		 * Value(Value.Type.OR,res1,res2); res1 = res; } return res; } else { return
		 * visitAnd_subject(andSubjects.get(i));
		 */
		return new Value(result);
	}

	public Value visitAnd_subject(SliceParser.And_subjectContext ctx) {
		List<SliceParser.SubjectContext> subjects = new ArrayList<SliceParser.SubjectContext>(ctx.subject());
		//System.err.println("visitAnd_select "+subjects.size() + " " +ctx.getText());
		Value[] result = new Value[subjects.size()];
		for (int i = 0; i < subjects.size(); i++) {
			result[i] = visit(subjects.get(i));
		}
		//to prevent subjects treated as and where the should be processed as or. For instance
		//if there is miltiple alpha atom, they should be treated as or
		if (subjects.size() > 1)
			isItAnd = true;
		else
			isItAnd = false;
		return new Value(result);
		/*
		 * if (subjects.size() > 1) { Value res = Value.VOID; Value res1 =
		 * visit(subjects.get(i)); for (int i = 1; i < subjects.size(); i++) { Value
		 * res2 = visit(subjects.get(i)); res = new Value(Value.Type.AND,res1,res2);
		 * res1 = res; } return res; } else { return visit(subjects.get(i)); }
		 */
	}

	public Value visitPredicates(SliceParser.PredicatesContext ctx) {
		return visitOr_Predicate(ctx.or_predicate());
	}

	public Value visitOr_Predicate(SliceParser.Or_predicateContext ctx) {
		List<SliceParser.And_predicateContext> andPredicates = new ArrayList<SliceParser.And_predicateContext>(
				ctx.and_predicate());
		if (subjects[0][0].asIChemObjectList().isEmpty())
			return new Value(false);
		for (SliceParser.And_predicateContext andPredicate : andPredicates) {
			Value res = visitAnd_Predicate(andPredicate);
			if (res.asBoolean() == true)
				return new Value(true);
		}
		return new Value(false);
	}

	public Value visitAnd_Predicate(SliceParser.And_predicateContext ctx) {
		//System.out.println("visitAnd_predicate "+ctx.getText());
		List<SliceParser.PredicateContext> predicates = new ArrayList<SliceParser.PredicateContext>(ctx.predicate());
		for (SliceParser.PredicateContext predicate : predicates) {
			Value res = visit(predicate);
			if (res.isBoolean()) {
				if (res.asBoolean() == false)
					return new Value(false);
			} else {
				// if it's not a boolean it's either a variable or an atom
				if (operatorType == 5 || operatorType == 6) {
					return hinderedComparison(res);
				}

			}
			/*
			 * else { if (testRelationBetweenTwoObjects(res) == false) return new
			 * Value(false); }
			 */

		}
		return new Value(true);
	}
	
	public Value visitPredicate(SliceParser.PredicateContext ctx) {
		if (ctx.comp_op() != null) {
			if (ctx.comp_op().LE2() != null) {
				operatorType = 2;
			} else if (ctx.comp_op().LT2() != null) {
				operatorType = 3;
			} else if (ctx.comp_op().GE2() != null) {
				operatorType = 1;
			} else if (ctx.comp_op().GT2() != null) {
				operatorType = 4;
			} else if (ctx.comp_op().EQ() != null) {
				operatorType = 7;
			}
			else {
				operatorType = 0;
			}
			//child 0 is the op and 1 is the predicate
			return visit(ctx.getChild(1));
		}
		else {
			//child 0 is the predicate as there is no  operator
			return visit(ctx.getChild(0));
		}
	}
	
	private Value hinderedComparison(Value res) {
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						IAtom a1 = (IAtom) subject.asIChemObject();
						IAtom a2 = (IAtom) res.asIChemObject();
						SliceAtom satom = new SliceAtom();
						int hydrogenCount1 = satom.getTotalHydrogenCount(a1, ac);
						int hydrogenCount2 = satom.getTotalHydrogenCount(a2, ac);
						boolean rslt = operatorType == 5 ? hydrogenCount1 < hydrogenCount2
								: hydrogenCount1 > hydrogenCount2;
						int res2 = rslt == true ? 1 : -1;
						if (relationType != res2) {
							andReturn = false;
							break;
						}

					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitSubject_appendages(SliceParser.Subject_appendagesContext ctx) {
		//System.out.println("visitSubject_appendages"+ctx.getText());
		List<IChemObject> res = new ArrayList<IChemObject>();
		String text = ctx.getText();
		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
		if (ctx.variable_name().size() == 2) {
			res.add(sf.getAppendages(ac, memory.get(ctx.variable_name(0).getText()).asIChemObjectList().get(0),memory.get(ctx.variable_name(1).getText()).asIChemObjectList().get(0)));
			
		} else if(ctx.INT().size() ==2){
			IAtom a1 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(0).getText()));
			IAtom a2 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(1).getText()));
			res.add(sf.getAppendages(ac, a2, a1));
		}else if (ctx.variable_name().size() == 1 && ctx.INT().size() == 1) {
			IAtom a1 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(0).getText())); 
			res.add(sf.getAppendages(ac, memory.get(ctx.variable_name(0).getText()).asIChemObjectList().get(0), a1));
		} else if (ctx.subject_atom_locs().size() == 2) {
			List<IChemObject> l1 = visitSubject_atom_locs(ctx.subject_atom_locs(0)).asIChemObjectList();
			List<IChemObject> l2 = visitSubject_atom_locs(ctx.subject_atom_locs(1)).asIChemObjectList();
			if (l1.size() == 1 && l2.size() == 1) {
				res.add(sf.getAppendages(ac, l1.get(0), l2.get(0)));
			} else {
				IAtomContainer select = DefaultChemObjectBuilder.getInstance().newAtomContainer();
				for (IChemObject a1 : l1) {
					for (IChemObject a2 : l2) {
						IAtomContainer target = sf.getAppendages(ac, a1, a2);
						for (IAtom a : target.atoms()) {
							if (!select.contains(a)) {
								select.addAtom(a);
							}
						}
						for (IBond b : target.bonds()) {
							if (!select.contains(b)) {
								select.addBond(b);
							}
						}
					}
				}
				res.add(select);
			}

		}
		return new Value(res);
	}

	public Value visitPredicate_appendages(SliceParser.Predicate_appendagesContext ctx) {
		//System.out.println("predicate appendages");
		List<IChemObject> res = new ArrayList<IChemObject>();
		String text = ctx.getText();
		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
		if (ctx.variable_name().size() == 2) {
			res.add(sf.getAppendages(ac, memory.get(ctx.variable_name(0).getText()).asIChemObject(),
					memory.get(ctx.variable_name(1).getText()).asIChemObject()));
		} else if (ctx.INT().size() == 2) {
			IAtom a1 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(0).getText()));
			IAtom a2 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(1).getText()));
			res.add(sf.getAppendages(ac, a2, a1));
		} else if (ctx.variable_name().size() == 1 && ctx.INT().size() == 1) {
			IAtom a1 = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT(0).getText()));
			res.add(sf.getAppendages(ac, memory.get(ctx.variable_name(0).getText()).asIChemObject(), a1));
		} else if (ctx.subject_atom_locs().size() == 2) {
			List<IChemObject> l1 = visitSubject_atom_locs(ctx.subject_atom_locs(0)).asIChemObjectList();
			List<IChemObject> l2 = visitSubject_atom_locs(ctx.subject_atom_locs(1)).asIChemObjectList();
			if (l1.size() == 1 && l2.size() == 1) {
				res.add(sf.getAppendages(ac, l1.get(0), l2.get(0)));
			} else {
				IAtomContainer select = DefaultChemObjectBuilder.getInstance().newAtomContainer();
				for (IChemObject a1 : l1) {
					for (IChemObject a2 : l2) {
						IAtomContainer target = sf.getAppendages(ac, a1, a2);
						for (IAtom a : target.atoms()) {
							if (!select.contains(a)) {
								select.addAtom(a);
							}
						}
						for (IBond b : target.bonds()) {
							if (!select.contains(b)) {
								select.addBond(b);
							}
						}
					}
				}
				res.add(select);
			}

		}
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtomContainer) {
						IAtomContainer ac1 = (IAtomContainer) obj;
						IAtomContainer ac2 = (IAtomContainer) res.get(0);
						
						/*DepictionGenerator dg = new DepictionGenerator().withSize(512, 512)
			                    .withAtomColors();
			            try {
							dg.depict(ac1).writeTo("/Users/noulehoilemos2/Documents/1390/ac1.png");
							dg.depict(ac2).writeTo("/Users/noulehoilemos2/Documents/1390/ac2.png");
							dg.depict(ac).writeTo("/Users/noulehoilemos2/Documents/1390/ac.png");
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					

						/*for(IAtom a : ac1.atoms())
						{
							System.out.print(a.getSymbol()+ "-"+ a.getIndex()+" ");
						}
						System.out.println();
						for(IBond a : ac1.bonds())
						{
							System.out.print(a.getBegin().getIndex()+ "-"+ a.getEnd().getIndex()+";");
						}
						System.out.println("^^^");
						
						for(IAtom a : ac2.atoms())
						{
							System.out.print(a.getSymbol()+ "-"+ a.getIndex()+" ");
						}
						System.out.println();
						for(IBond a : ac2.bonds())
						{
							System.out.print(a.getBegin().getIndex()+ "-"+ a.getEnd().getIndex()+";");
						}
						System.out.println("***");
						for(IAtom a : ac.atoms())
						{
							System.out.print(a.getSymbol()+ a.getIndex()+ " ");
						}
						System.out.println();
						for(IBond a : ac.bonds())
						{
							System.out.println(a.getBegin().getIndex()+ "- "+ a.getEnd().getIndex());
						}
						System.out.println("+++"+ areTwoAtomContainerEquals(ac1, ac2));*/
						
						int result = areTwoAtomContainerEquals(ac1, ac2) ? 1 : -1;
						if (result != relationType) {
							andReturn = false;
							break;
						}
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	private boolean areTwoAtomContainerEquals(IAtomContainer ac1, IAtomContainer ac2) {
		IFingerprinter fcfp = new CircularFingerprinter(CircularFingerprinter.CLASS_FCFP6);
		IFingerprinter ecfp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP6);
		try {
			return fcfp.getFingerprint(ac1).equals(fcfp.getFingerprint(ac2))
					&& ecfp.getFingerprint(ac1).equals(ecfp.getFingerprint(ac2));
		} catch (CDKException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return true;
	}

	public Value visitSubject_atom(SliceParser.Subject_atomContext ctx) {
		List<IChemObject> res = new ArrayList<IChemObject>();
		String id = ctx.INT().getText();
		for (IAtom atom : ac.atoms()) {
			if (atom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).toString().equals(id)) {
				res.add(atom);
				return new Value(res);
			}
		}
		return Value.VOID;
	}
	

	public Value visitSubject_bond(SliceParser.Subject_bondContext ctx) {
		List<IChemObject> res = new ArrayList<IChemObject>();
		
		if (ctx.variable_name().size() == 1) {
			if (ctx.variable_name(0) != null) {
				IAtom atom2 = (IAtom) memory.get(ctx.variable_name(0).getText()).asIChemObjectList().get(0);
				String id1 = ctx.INT().get(0).getText();
				for (IAtom atom : ac.atoms()) {
					if (atom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).toString().equals(id1)) {
						res.add(ac.getBond(atom2, atom));
						return new Value(res);
					}
				}
			} else
				return Value.VOID;
		} else if (ctx.variable_name().size() == 2) {
			if (ctx.variable_name(0) != null && ctx.variable_name(1) != null) {
				IAtom atom1 = (IAtom) memory.get(ctx.variable_name(0).getText()).asIChemObjectList().get(0);
				IAtom atom2 = (IAtom) memory.get(ctx.variable_name(1).getText()).asIChemObjectList().get(0);
				res.add(ac.getBond(atom1, atom2));
				return new Value(res);
			} else
				return Value.VOID;
		} else {
			String id1 = ctx.INT().get(0).getText();
			String id2 = ctx.INT().get(1).getText();
			IAtom atom2 = null;
			for (IAtom atom : ac.atoms()) {
				if (atom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).toString().equals(id1)
						|| atom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).toString().equals(id2)) {
					if (atom2 == null)
						atom2 = atom;
					else {
						res.add(ac.getBond(atom2, atom));
						return new Value(res);
					}
				}
			}
		}

		return Value.VOID;
	}

	public Value visitSubject_ring(SliceParser.Subject_ringContext ctx) {
		List<IChemObject> res = new ArrayList<IChemObject>();
		// TODO might need to be improved? look functions in ChemSet.java
		if (ctx.CURRENT() != null) {
			res.add((IRingSet) memory.get("curent ring"));
			return new Value(res);
		} else {
			SliceSet cs = new SliceSet();
			try {
				res.add(cs.getAllRing(ac));
			} catch (CDKException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			return new Value(res);
		}
	}

	public Value visitSubject_molecule(SliceParser.Subject_moleculeContext ctx) {
		List<IChemObject> res = new ArrayList<IChemObject>();
		res.add(ac);
		return new Value(res);
	}

	public Value visitSubject_atom_locs(SliceParser.Subject_atom_locsContext ctx) {
		//System.out.println("atom locs :"+ ctx.getText());
		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
		List<IChemObject> refs = new ArrayList<IChemObject>();
		if (ctx.INT() != null) {
			// TODO check if it selcts according to the atom maping
			IAtom ref = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT().getText()));
			refs.add(ref);
		} else if (ctx.variable_name() != null) {
			String varName = ctx.variable_name().getText();
			if (memory.get(varName).isIChemObject()) {
				IAtom ref = (IAtom) memory.get(varName).asIChemObject();
				refs.add(ref);
			}
			else if (memory.get(varName).isList()) {
				refs = memory.get(varName).asIChemObjectList();
			}
		}
			
		List<IAtom> locs = new ArrayList<IAtom>();
		int token = ctx.atom_loc().getStart().getType();
		SliceType.Loc loc = SliceType.Loc.valueOf(getTokenName(token));
		for (int i = 0; i < refs.size(); i++) {
			IAtom ref = (IAtom) refs.get(i);
			if (ctx.atomtype() != null) {
				SliceAtom satom = new SliceAtom();
				int token2 = ctx.atomtype().getStart().getType();
				Elements elt = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token2)));
				if (ctx.WITHIN() != null) {
					locs = sf.getChemObjectByLocs(ac, elt, SliceType.Loc.ALPHA, ref, whereConf);
					if (loc.equals(SliceType.Loc.BETA)) {
						locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.BETA, ref, whereConf));
					} else if (loc.equals(SliceType.Loc.GAMMA)) {
						locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.BETA, ref, whereConf));
						locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.GAMMA, ref, whereConf));
					}
				} else {
					
					locs = sf.getChemObjectByLocs(ac, elt, loc, ref, whereConf);
				}
			} else {
				// TODO make separate function for within case
				// TODO incusing explicit hydrogen
				if (ctx.WITHIN() != null) {
					locs = sf.getChemObjectByLocs(ac, SliceType.Loc.ALPHA, ref, whereConf);
					if (loc.equals(SliceType.Loc.BETA)) {
						locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.BETA, ref, whereConf));
					} else if (loc.equals(SliceType.Loc.GAMMA)) {
						locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.BETA, ref, whereConf));
						locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.GAMMA, ref, whereConf));
					}
				} else {

					locs = sf.getChemObjectByLocs(ac, loc, ref, whereConf);
				}
			}
		}
		
		List<IAtom> toRemove = new ArrayList<IAtom>();
		// remove explicit hydrogens
		if (ctx.NOT() != null) {
			for (IAtom a : locs) {
				if (a.getSymbol().equals("H")) {
					toRemove.add(a);
				}
			}
			locs.removeAll(toRemove);
		}
		
		if(ctx.NUMBER_LHASA() != null) {
			return new Value(Double.valueOf(locs.size()));
		}
		
		return new Value(locs);

	}
	
	public Value visitSubject_or_predicate_atom_type(SliceParser.Subject_or_predicate_atom_typeContext ctx) {
		//System.out.println("visitSubject_or_predicate_atom_type"+ctx.getText());
		int token = ctx.atomtype().getStart().getType();
		SliceAtom satom = new SliceAtom();
		String type = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
		// subject is already defined
		if (relationType != 0) {
			// only is / is not relation should normally be used
			boolean toReturn = false;
			for (Value[] or : subjects) {
				boolean andReturn = true;
				for (Value and : or) {
					List<IChemObject> objects = and.asIChemObjectList();
					for (IChemObject obj : objects) {
						if (obj instanceof IAtom) {
							int res = ((IAtom) obj).getSymbol().equals(type) ? 1 : -1;
							if (relationType != res) {
								andReturn = false;
								break;
							}

						}
					}
					if (!andReturn) 
						break;
				}
				if (andReturn) {
					toReturn = true;
					break;
				}
			}
			//System.out.println(toReturn);
			return new Value(toReturn);
		}
		// subject is not defined
		else {
			List<IChemObject> res = new ArrayList<IChemObject>();
			for (IAtom atom : ac.atoms()) {
				if (atom.getSymbol().equals(type)) {
					if (isWhereRight(atom, whereConf))
						res.add(atom);
					// else
					// System.out.println(atom.getSymbol() + " " +
					// atom.getProperty(ChemConstants.ONPATH) + " "+ type + " " + isWhereRight(atom,
					// conf));
				}
			}
			// System.out.println(res);
			return new Value(res);
		}
		// return new Value(ChemAtom.atomType.valueOf(getTokenName(token)));
	}

	public Value visitPredicate_atom(SliceParser.Predicate_atomContext ctx) {
		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
		IAtom atom = (IAtom)sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT().getText()));
		
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						IAtom obj_atom = (IAtom) obj;
						if (obj_atom != atom) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_atom_property(SliceParser.Predicate_atom_propertyContext ctx) {
		//System.out.println("visitPredicate_atom_property "+ctx.getText()+ " "+SliceAtom.atomProp.valueOf(getTokenName(ctx.atom_properties().getStart().getType())));
		SliceAtom satom = new SliceAtom();
		int token = ctx.atom_properties().getStart().getType();
		atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token));
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						// TODO atom 1 and atom2 or atom and bond
						if (ctx.stereochemistry_predicate2() != null) {
							// TODO AtomContainerManipulator
							Value v = visit(ctx.stereochemistry_predicate2().getChild(0));
							int res = relationType;
							try {
								if (v.asIChemObject() instanceof IAtom) {
									res = satom.isProp(prop, (IAtom) obj, (IAtom) v.asIChemObject(), null, ac, location) ? 1 : -1;
								}
								else if ((v.asIChemObject() instanceof IBond)) {
									int res2 = satom.isProp(prop, (IAtom) obj, ((IBond) v.asIChemObject()).getBegin(), null, ac, location) ? 1 : -1;
									int res3 = satom.isProp(prop, (IAtom) obj, ((IBond) v.asIChemObject()).getEnd(), null, ac, location) ? 1 : -1;
									//favor true as using bond for cis trans bight be confusing.
									if (res2 != res && res3 != res)
										res = res2;
										
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							if (res != relationType) {
								andReturn = false;
								break;
							}
						}else if(ctx.variable_name() != null){
							String varName = ctx.variable_name().getText();
							IAtom ref = (IAtom) memory.get(varName).asIChemObject();
							int res = relationType;
							
							try {
								res = satom.isProp(prop, (IAtom) obj, ref, null, ac, location) ? 1 : -1;
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							if (res != relationType) {
								andReturn = false;
								break;
							}
						}else if (ctx.predicate_atom() != null){
							ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
							IAtom ref = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.predicate_atom().INT().getText()));

							int res = relationType;
							try {
								res = satom.isProp(prop, (IAtom) obj, ref, null, ac, location) ? 1 : -1;
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							if (res != relationType) {
								andReturn = false;
								break;
							}
						}else {
							int res = relationType;
							try {
								res = satom.isProp(prop, (IAtom) obj, null, null, ac, location) ? 1 : -1;
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							if (res != relationType) {
								andReturn = false;
								break;
							}
						}

					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		//System.out.println(toReturn);
		return new Value(toReturn);
	}

	public Value visitPredicate_atom_center_property(SliceParser.Predicate_atom_center_propertyContext ctx) {
		//System.out.println("visitPredicate_atom_center_property "+ctx.getText());
		SliceAtom satom = new SliceAtom();
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			//lowerSystem.out.println("or"+or);
			for (Value and : or) {
				//System.out.println("and"+and);
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = 0;
						if (ctx.centre_stmt().PRIMARY_CENTER() != null) {
							res = satom.isCenter((IAtom) obj, ac, "PRIMARY_CENTER") ? 1 : -1;
						} else if (ctx.centre_stmt().SECONDARY_CENTER() != null) {
							res = satom.isCenter((IAtom) obj, ac, "SECONDARY_CENTER") ? 1 : -1;
						} else if (ctx.centre_stmt().TERTIARY_CENTER() != null) {
							res = satom.isCenter((IAtom) obj, ac, "TERTIARY_CENTER") ? 1 : -1;
						} else if (ctx.centre_stmt().QUATERNARY_CENTER() != null) {
							res = satom.isCenter((IAtom) obj, ac, "QUATERNARY_CENTER") ? 1 : -1;
						}
						if (relationType > 1 || relationType < -1) {
							res = res * 2;
						}
						if (res != relationType) {
							andReturn = false;
							break;
						}
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_atom_type_count(SliceParser.Predicate_atom_type_countContext ctx) {
		//System.out.println("visitPredicate_atom_type_count "+ctx.getText());
		SliceAtom satom = new SliceAtom();
		int token = ctx.subject_or_predicate_atom_type().getStart().getType();
		String symbol = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token))).symbol();
		int target = Integer.parseInt(ctx.INT().getText());
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtomContainer) {
						int res = quantitativeComparison(satom.atomTypeCount(symbol, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtom) {
						int res = quantitativeComparison(satom.atomTypeCount((IAtom) obj, symbol, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		//System.out.println(toReturn);
		return new Value(toReturn);
	}

	public Value visitPredicate_charge_count(SliceParser.Predicate_charge_countContext ctx) {
		SliceAtom satom = new SliceAtom();
		int target = Integer.parseInt(ctx.INT().getText());
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res;
						if (ctx.charge_stmt().PLUS_CHARGE() != null) {
							res = quantitativeComparison(satom.numberOfPositiveCharge((IAtom) obj, location), target);
						} else {
							res = quantitativeComparison(satom.numberOfNegativeCharge((IAtom) obj, location), target);
						}
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_alkyl_count(SliceParser.Predicate_alkyl_countContext ctx) {
		SliceAtom satom = new SliceAtom();
		int target = Integer.parseInt(ctx.INT().getText());

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(satom.numberOfAlkyl((IAtom) obj, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}
	
	
	public Value visitPredicate_hetero_count(SliceParser.Predicate_hetero_countContext ctx) {
		SliceAtom satom = new SliceAtom();
		int target = Integer.parseInt(ctx.INT().getText());
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(satom.numberOfHetero((IAtom) obj, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_bond_property(SliceParser.Predicate_bond_propertyContext ctx) {
		//System.out.println("visitPredicate_bond_property "+ctx.getText());
		int token = ctx.bond_properties().getStart().getType();
		SliceBond.bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
		SliceBond sbond = new SliceBond();
		boolean toReturn = false;
		for (int i = 0; i < subjects.length; i++) {
			Value[] or = subjects[i];
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IBond) {
						if (prop.equals(SliceBond.bondProp.ANTI) || prop.equals(SliceBond.bondProp.SYN)) {
							if (i + 1 < subjects.length) {
								Value[] or2 = subjects[i + 1];
								for (Value and2 : or2) {
									List<IChemObject> objects2 = and2.asIChemObjectList();
									for (IChemObject obj2 : objects2) {
										if (obj2 instanceof IBond) {
											int res = relationType;
											try {
												res = sbond.isProp(prop, (IBond) obj, (IBond) obj2, null, ac, location) ? 1 : -1;
											} catch (CDKException e) {
												// TODO Auto-generated catch block
												e.printStackTrace();
											}
											if (res != relationType) {
												andReturn = false;
												break;
											}
										}
									}
								}

							}
						} else {
							int res = relationType;
							try {
								res = sbond.isProp(prop, (IBond) obj, null, null, ac, location) ? 1 : -1;
								if (res != relationType) {
									andReturn = false;
									break;
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_atom_or_bond_property(SliceParser.Predicate_atom_or_bond_propertyContext ctx) {

		//System.out.println("visitPredicate_bond_property "+ctx.getText());
		int token = ctx.atom_or_bond_properties().getStart().getType();
		boolean toReturn = false;
		for (int i = 0; i < subjects.length; i++) {
			Value[] or = subjects[i];
			/*if (or == null)
			{	
				continue;
			}*/
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj1 : objects) {
					if (obj1 instanceof IBond) {
						SliceBond.bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
						SliceBond sbond = new SliceBond();
						if (prop.equals(SliceBond.bondProp.ANTI) || prop.equals(SliceBond.bondProp.SYN)) {
							//LAZY WAY by comparing bond stereo
							//TODO considered about the path
							if (ctx.stereochemistry_predicate1() != null) {
								Value v = visit(ctx.stereochemistry_predicate1().getChild(0));
								IChemObject chemObj = v.asIChemObject();
								int res = relationType;
								try {
									if (chemObj instanceof IAtom) {
										res = sbond.isProp(prop, (IBond) obj1, null, (IAtom) chemObj, ac, location) ? 1 : -1;
									}
									else if (chemObj instanceof IBond) {
										res = sbond.isProp(prop, (IBond) obj1, (IBond) chemObj, null, ac, location) ? 1 : -1;
									}
								} catch (CDKException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								if (res != relationType) {
									andReturn = false;
									break;
								}
							}
							else if (ctx.stereochemistry_predicate3() != null) {
								Value v = visit(ctx.stereochemistry_predicate1().getChild(0));
								IChemObject chemObj = v.asIChemObject();
								int res = relationType;
								try {
									if (chemObj instanceof IAtom) {
										res = sbond.isProp(prop, (IBond) obj1, null, (IAtom) chemObj, ac, location) ? 1 : -1;
									}
									else if (chemObj instanceof IBond) {
										res = sbond.isProp(prop, (IBond) obj1, (IBond) chemObj, null, ac, location) ? 1 : -1;
									}
								} catch (CDKException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								if (res != relationType) {
									andReturn = false;
									break;
								}
							}
							else {
								if (i + 1 < subjects.length) {
									Value[] and2 = subjects[i + 1];
									for (Value or2 : and2) {
										List<IChemObject> objects2 = or2.asIChemObjectList();
										for (IChemObject obj2 : objects2) {
											if (obj2 instanceof IBond) {
												int res = relationType;
												try {
													res = sbond.isProp(prop, (IBond) obj1, (IBond) obj2, null, ac, location) ? 1 : -1;
												} catch (CDKException e) {
													// TODO Auto-generated catch block
													e.printStackTrace();
												}
												if (res != relationType) {
													andReturn = false;
													break;
												}
											}
										}
									}
								}
							}
							
						} else {
							int res = relationType;
							try {
								res = sbond.isProp(prop, (IBond) obj1, null, null, ac, location) ? 1 : -1;
								if (res != relationType) {
									andReturn = false;
									break;
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					} else if (obj1 instanceof IAtom) {
						atomProp prop = SliceAtom.atomProp.valueOf(getTokenName(token));
						SliceAtom satom = new SliceAtom();
						if (prop.equals(SliceAtom.atomProp.ANTI) || prop.equals(SliceAtom.atomProp.SYN)) {
							if (i + 1 < subjects.length) {
								Value[] and2 = subjects[i + 1];
								for (Value or2 : and2) {
									List<IChemObject> objects2 = or2.asIChemObjectList();
									for (IChemObject obj2 : objects2) {
										if (obj2 instanceof IBond) {
											int res = relationType;
											try {
												res = satom.isProp(prop, (IAtom) obj1, (IAtom) obj2, null, ac, location) ? 1 : -1;
											} catch (CDKException e) {
												// TODO Auto-generated catch block
												e.printStackTrace();
											}
											if (res != relationType) {
												andReturn = false;
												break;
											}
										}
									}
								}
							}
						} else {
							int res = relationType;
							try {
								res = satom.isProp(prop, (IAtom) obj1, null, null, ac, location) ? 1 : -1;
								if (res != relationType) {
									andReturn = false;
									break;
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);

	}

	public Value visitPredicate_atom_locs(SliceParser.Predicate_atom_locsContext ctx) {
		int target = Integer.parseInt(ctx.INT().getText());
		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						IAtom ref = (IAtom) obj;
						List<IAtom> locs = new ArrayList<IAtom>();
						int token = ctx.atom_loc().getStart().getType();
						SliceType.Loc loc = SliceType.Loc.valueOf(getTokenName(token));
						if (ctx.atomtype() != null) {
							SliceAtom satom = new SliceAtom();
							int token2 = ctx.atomtype().getStart().getType();
							Elements elt = satom.getCDKAtomType(SliceAtom.atomType.valueOf(getTokenName(token2)));
							if (ctx.WITHIN() != null) {
								locs = sf.getChemObjectByLocs(ac, elt, SliceType.Loc.ALPHA, ref, whereConf);
								if (loc.equals(SliceType.Loc.BETA)) {
									locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.BETA, ref, whereConf));
								} else if (loc.equals(SliceType.Loc.GAMMA)) {
									locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.BETA, ref, whereConf));
									locs.addAll(sf.getChemObjectByLocs(ac, elt, SliceType.Loc.GAMMA, ref, whereConf));
								}
							} else {
								locs = sf.getChemObjectByLocs(ac, elt, loc, ref, whereConf);
							}
						} else {
							// TODO make separate function for within case
							// TODO incusing explicit hydrogen
							if (ctx.WITHIN() != null) {
								locs = sf.getChemObjectByLocs(ac, SliceType.Loc.ALPHA, ref, whereConf);
								if (loc.equals(SliceType.Loc.BETA)) {
									locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.BETA, ref, whereConf));
								} else if (loc.equals(SliceType.Loc.GAMMA)) {
									locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.BETA, ref, whereConf));
									locs.addAll(sf.getChemObjectByLocs(ac, SliceType.Loc.GAMMA, ref, whereConf));
								}
							} else {
								locs = sf.getChemObjectByLocs(ac, loc, ref, whereConf);
							}
						}
						List<IAtom> toRemove = new ArrayList<IAtom>();
						// remove explicit hydrogens
						if (ctx.NOT() != null) {
							for (IAtom a : locs) {
								if (a.getSymbol().equals("H")) {
									toRemove.add(a);
								}
							}
							locs.removeAll(toRemove);
						}
						int res = quantitativeComparison(locs.size(), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);

	}

	public Value visitPredicate_atom_or_bond_or_group_property(SliceParser.Predicate_atom_or_bond_or_group_propertyContext ctx) {	
		//System.out.println("visitPredicate_atom_or_bond_or_group_property "+ctx.getText());
		int token = ctx.atom_or_bond_or_group_properties().getStart().getType();
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj1 : objects) {
					int res = relationType;
					if (obj1 instanceof IBond) {
						SliceBond sbond = new SliceBond();
						SliceBond.bondProp prop = SliceBond.bondProp.valueOf(getTokenName(token));
						try {
							res = sbond.isProp(prop, (IBond) obj1, null, null, ac, location) ? 1 : -1;
						} catch (CDKException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					} else if (obj1 instanceof IAtom) {
						
						if (ctx.INT() == null) //STEFI
						{
							SliceAtom satom = new SliceAtom();
							SliceGroup sgroup = new SliceGroup();
							SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));
							//System.out.println("carbon :"+ carbonCentered);
							//System.out.println("withdraw group :"+sgroup.getExpandableWithDrawing((IAtom) obj1, ac, location).size());
							//System.out.println("withdraw group :"+sgroup.getNonExpandableWithDrawing((IAtom) obj1, ac, location).size());

							//System.out.println("withdraw group :"+sgroup.groupCount(prop, (IAtom) obj1, ac, location));

							//System.out.println("withdraw group :"+sgroup.hasWithDrawing((IAtom) obj1, ac, location));
								//	groupCount(prop, (IAtom) obj1, ac, location));
							//		getNonExpandableWithDrawing((IAtom) obj1, ac, location).size());
							//System.out.println("withdraw group :"+ sgroup.groupCount(prop, null, (IAtom) obj1, location));
							//		hasGroup(prop, ac, location));
							//sgroup.   prop.getWithDrawing(ac, location).size());
							//System.out.println("withdraw :"+ satom.hasProp(SliceAtom.atomProp.valueOf(getTokenName(token)), (IAtom) obj1, ac, location));
							res = sgroup.hasWithDrawing((IAtom) obj1, ac, location)? 1 : -1;;
							
						}
						else
						{
							int target = Integer.parseInt(ctx.INT().getText());
							SliceAtom satom = new SliceAtom();
							res = quantitativeComparison(
									satom.numberOfProp(SliceAtom.atomProp.valueOf(getTokenName(token)), (IAtom) obj1, ac, location),
									target);
						}
					} else if (obj1 instanceof IAtomContainer) {
						SliceGroup sgroup = new SliceGroup();
						SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));
						// TODO currently not have any statement molecule is group property
					}
					if (res != relationType) {
						andReturn = false;
						break;
					}
				}
				if (!andReturn) 
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_group_property(SliceParser.Predicate_group_propertyContext ctx) {
		//System.out.println("visitPredicate_group_property :"+ ctx.getText());
		int token = ctx.group_properties().getStart().getType();
		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(true);
		SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = sgroup.groupCount(prop, (IAtom) obj, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						int res = sgroup.groupCount(prop, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_group_property_count(SliceParser.Predicate_group_property_countContext ctx) {
		//System.out.println("visitPredicate_group_property_count:"+ ctx.getText());
		int token = ctx.group_properties().getStart().getType();
		int target = Integer.parseInt(ctx.INT().getText());
		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(false);
		SliceGroup.groupProp prop = SliceGroup.groupProp.valueOf(getTokenName(token));

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(sgroup.groupCount(prop, (IAtom) obj, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						sgroup.setCarbonCentered(true);
						int res = quantitativeComparison(sgroup.groupCount(prop, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_functional_group(SliceParser.Predicate_functional_groupContext ctx) {
		//System.out.println(ctx.getText() + location);
		int token = ctx.functional_group().getStart().getType();
		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(true);
		SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = sgroup.functionalGroupCount(fg, (IAtom) obj, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						int res = sgroup.functionalGroupCount(fg, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_functional_group_count(SliceParser.Predicate_functional_group_countContext ctx) {
		//System.out.println("visitPredicate_functional_group_count "+ctx.getText());
		int token = ctx.functional_group().getStart().getType();
		int target = Integer.parseInt(ctx.INT().getText());
		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(false);
		SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));
		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(sgroup.functionalGroupCount(fg, (IAtom) obj, ac, location),
								target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {

						sgroup.setCarbonCentered(true);
						int res = quantitativeComparison(sgroup.functionalGroupCount(fg, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_non_functional_group_property(SliceParser.Predicate_non_functional_groupContext ctx) {
		int token = ctx.non_functional_group().getStart().getType();

		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(true);
		SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = sgroup.functionalGroupCount(fg, (IAtom) obj, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						int res = sgroup.functionalGroupCount(fg, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_non_functional_group_count(
			SliceParser.Predicate_non_functional_group_countContext ctx) {
		//System.out.println("visitPredicate_non_functional_group_count "+ctx.getText());
		int token = ctx.non_functional_group().getStart().getType();
		int target = Integer.parseInt(ctx.INT().getText());

		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(false);
		SliceGroup.FunctionalGroup fg = SliceGroup.FunctionalGroup.valueOf(getTokenName(token));

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(sgroup.functionalGroupCount(fg, (IAtom) obj, ac, location),
								target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						sgroup.setCarbonCentered(true);
						int res = quantitativeComparison(sgroup.functionalGroupCount(fg, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_smarts_group_property(SliceParser.Predicate_smarts_groupContext ctx) {
		String smarts = ctx.smarts().STRING().getText();

		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(true);

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = sgroup.smartsCount(smarts, (IAtom) obj, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						int res = sgroup.smartsCount(smarts, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitPredicate_smarts_group_property_count(SliceParser.Predicate_smarts_group_countContext ctx) {
		String smarts = ctx.smarts().STRING().getText();
		int target = Integer.parseInt(ctx.INT().getText());

		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(false);

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(sgroup.smartsCount(smarts, (IAtom) obj, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						sgroup.setCarbonCentered(true);
						int res = quantitativeComparison(sgroup.smartsCount(smarts, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}
	public Value visitPredicate_smarts_group(SliceParser.Predicate_smarts_groupContext ctx) {
		//System.out.println("smarts"+ ctx.smarts().smarts_char().getText());
		String smarts = ctx.smarts().smarts_char().getText();
		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(true);

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = sgroup.smartsCount(smarts, (IAtom) obj, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						int res = sgroup.smartsCount(smarts, ac, location) > 0 ? 1 : -1;
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		//System.out.println(toReturn);
		return new Value(toReturn);
	}

	public Value visitPredicate_smarts_group_count(SliceParser.Predicate_smarts_group_countContext ctx) {
		//System.out.println("smarts " + ctx.smarts().smarts_char().getText()+" int :"+Integer.parseInt(ctx.INT().getText()));
		String smarts = ctx.smarts().smarts_char().getText();
		int target = Integer.parseInt(ctx.INT().getText());

		SliceGroup sgroup = new SliceGroup();
		sgroup.setCarbonCentered(false);

		boolean toReturn = false;
		for (Value[] or : subjects) {
			boolean andReturn = true;
			for (Value and : or) {
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (obj instanceof IAtom) {
						int res = quantitativeComparison(sgroup.smartsCount(smarts, (IAtom) obj, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else if (obj instanceof IAtomContainer) {
						sgroup.setCarbonCentered(true);
						int res = quantitativeComparison(sgroup.smartsCount(smarts, ac, location), target);
						if (res != relationType) {
							andReturn = false;
							break;
						}
					} else {
						return Value.VOID;
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}
	public Value visitPredicate_ring(SliceParser.Predicate_ringContext ctx) {
		//System.out.println(ctx.getText());
		SliceSet cs = new SliceSet();
		IRingSet allRings = null;
		try {
			allRings = cs.getAllRing(ac);
		} catch (CDKException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		IRingSet newSet = DefaultChemObjectBuilder.getInstance().newInstance(IRingSet.class);
		for (IAtomContainer ac2 : allRings.atomContainers()) {
			boolean keepRing = true;
			if ((boolean) ac2.getAtom(0).getProperty(location) == false) {
				keepRing = false;
			}
			if (ctx.ALIPHATIC() != null) {
				int res = !ac2.getAtom(0).isAromatic() ? 1 : -1;
				if (res == relationType) {
					keepRing = true;
				} else {
					keepRing = false;
				}
			}
			if (ctx.AROMATIC() != null) {
				int res = ac2.getAtom(0).isAromatic() ? 1 : -1;
				if (res == relationType) {
					keepRing = true;
				} else {
					keepRing = false;
				}
			}
			if (ctx.ring_size() != null) {
				int target = Integer.parseInt(ctx.INT(0).getText());
				if (ctx.OR_SMALLER() != null) {
					int res = ac2.getAtomCount() <= target ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				} else if (ctx.OR_LARGER() != null) {
					int res = ac2.getAtomCount() >= target ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				} else if (ctx.THROUGH() != null) {
					int res = ac2.getAtomCount() >= target
							&& ac2.getAtomCount() <= Integer.parseInt(ctx.INT(1).getText()) ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				} else {
					int res = ac2.getAtomCount() == target ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				}
			}
			if (ctx.ring_prefix_prop() != null) {
				boolean isCarboxy = true;
				boolean isHetero = false;
				for (IAtom a : ac2.atoms()) {
					if (ctx.ring_prefix_prop().CARBOCYCLIC() != null) {
						if (!a.getSymbol().equals("C")) {
							isCarboxy = false;
							break;
						}
					} else if (ctx.ring_prefix_prop().HETEROCYCLIC() != null) {
						if (!a.getSymbol().equals("C")) {
							isHetero = true;
							break;
						}
					}
				}
				if (ctx.ring_prefix_prop().CARBOCYCLIC() != null) {
					int res = isCarboxy ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				} else if (ctx.ring_prefix_prop().HETEROCYCLIC() != null) {
					int res = isHetero ? 1 : -1;
					if (res == relationType) {
						keepRing = true;
					} else {
						keepRing = false;
					}
				}
			}
			if (keepRing) {
				newSet.addAtomContainer(ac2);
			}
		}

		if (newSet.getAtomContainerCount() == 0) {
			if (-1 == relationType) {
				return new Value(true);
			} else {
				return new Value(false);
			}
		}
		boolean toReturn = false;
		for (int i = 0; i < subjects.length; i++) {
			Value[] or = subjects[i];
			boolean andReturn = true;
			for (int j = 0; j < or.length; j++) {
				Value and = or[j];
				List<IChemObject> objects = and.asIChemObjectList();
				for (IChemObject obj : objects) {
					if (ctx.ring_prefix_prop() != null) {
						if (ctx.ring_prefix_prop().COMMON() != null) {
							if (j + 1 < or.length) {
								Value and2 = or[j + 1];
								List<IChemObject> objects2 = and2.asIChemObjectList();
								for (IChemObject obj2 : objects2) {
									int res = relationType;
									if (obj instanceof IAtom && obj2 instanceof IBond) {
										SliceAtom satom = new SliceAtom();
										try {
											res = satom.isCommon((IAtom) obj, (IBond) obj2, newSet) ? 1 : -1;
										} catch (CDKException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
										if (res != relationType) {
											andReturn = false;
											break;
										}
									} else if (obj instanceof IAtom && obj2 instanceof IAtom) {
										SliceAtom satom = new SliceAtom();
										try {
											res = satom.isCommon((IAtom) obj, (IAtom) obj2, newSet) ? 1 : -1;
										} catch (CDKException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
										if (res != relationType) {
											andReturn = false;
											break;
										}
									} else if (obj instanceof IBond && obj2 instanceof IAtom) {
										SliceBond sbond = new SliceBond();
										try {
											res = sbond.isCommon((IBond) obj, (IAtom) obj2, newSet) ? 1 : -1;
										} catch (CDKException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
										if (res != relationType) {
											andReturn = false;
											break;
										}
									} else if (obj instanceof IBond && obj2 instanceof IBond) {
										SliceBond sbond = new SliceBond();
										try {
											res = sbond.isCommon((IBond) obj, (IBond) obj2, newSet) ? 1 : -1;
										} catch (CDKException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
										if (res != relationType) {
											andReturn = false;
											break;
										}
									}
								}
							}
						}
						//System.out.println("exit");
						else {
							if (obj instanceof IAtom) {
								SliceAtom sa = new SliceAtom();
								int res = 1;
								try {
									res = sa.isInCurrentRing((IAtom) obj, newSet) ? 1 : -1;
									// no need to check with relationType as rings have already been filtered using
									// it.
									// The only thing to check is if the current atom is part of the filtered ring
									// set
									if (res != 1) {
										andReturn = false;
										break;
									}
								} catch (CDKException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}

							} else if (obj instanceof IBond) {
								SliceBond sb = new SliceBond();
								int res = relationType;
								try {
									res = sb.isInCurrentRing((IBond) obj, newSet) ? 1 : -1;
									// no need to check with relationType as rings have already been filtered using
									// it.
									// The only thing to check is if the current bond is part of the filtered ring
									// set
									if (res != 1) {
										andReturn = false;
										break;
									}
								} catch (CDKException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}

							}
						}
					} else {
						if (obj instanceof IAtom) {
							SliceAtom sa = new SliceAtom();
							int res = 1;
							try {
								res = sa.isInCurrentRing((IAtom) obj, newSet) ? 1 : -1;
								// no need to check with relationType as rings have already been filtered using
								// it.
								// The only thing to check is if the current atom is part of the filtered ring
								// set
								if (res != 1) {
									andReturn = false;
									break;
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}

						} else if (obj instanceof IBond) {
							SliceBond sb = new SliceBond();
							int res = relationType;
							try {
								res = sb.isInCurrentRing((IBond) obj, newSet) ? 1 : -1;
								// no need to check with relationType as rings have already been filtered using
								// it.
								// The only thing to check is if the current bond is part of the filtered ring
								// set
								if (res != 1) {
									andReturn = false;
									break;
								}
							} catch (CDKException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}

						}
					}
				}
				if (!andReturn)
					break;
			}
			if (andReturn) {
				toReturn = true;
				break;
			}
		}
		return new Value(toReturn);
	}

	public Value visitSet_current_ring(SliceParser.Set_current_ringContext ctx) {
		//System.out.println("CTX:" +ctx.getText());
		List<IChemObject> res = new ArrayList<IChemObject>();
		SliceSet cs = new SliceSet();

		ExtractSubjectFromAtomContainer sf = new ExtractSubjectFromAtomContainer();
		List<IChemObject> refs = new ArrayList<IChemObject>();
		
		if (ctx.INT().size() == 2) {
			IAtom ref = (IAtom) sf.getChemObjectByID(ac, ChemicalObject.ATOM, Integer.parseInt(ctx.INT().get(1).getText()));
			refs.add(ref);
		}
		else{
			String varName = ctx.variable_name().getText();
			if (memory.get(varName).isIChemObject()) {
				IAtom ref = (IAtom) memory.get(varName).asIChemObject();
				refs.add(ref);
			}
			else if (memory.get(varName).isList()) {
				refs = memory.get(varName).asIChemObjectList();
			}
			
		}	
		int size_limit = Integer.parseInt(ctx.INT().get(0).getText());
		try {
			for (int i = 0; i < refs.size(); i++) {
				IAtom ref = (IAtom) refs.get(i);
				IRingSet rs = cs.getCurrentRing(ref, ac);
				
				//if (!(ctx.THE() != null && ctx.OR() != null)) {
					IAtomContainer target = null;
					boolean isRingFound = false;
					for (IAtomContainer ring : rs.atomContainers()) {
						if(ring.getAtomCount() == size_limit) {
							for (IAtom a : ring.atoms()) {
								if(ctx.OR() != null) {
									target = ring;
								}
								else {
									if (ctx.AROMATIC() != null && a.isAromatic()) {
										target = ring;
									} else if (ctx.AROMATIC() != null && !a.isAromatic()) {
										target = null;
										break;
									} else if (ctx.ALIPHATIC() != null && !a.isAromatic()) {
										target = ring;
									} else if (ctx.ALIPHATIC() != null && a.isAromatic()) {
										target = null;
										break;
									}
								}
								if (ctx.ring_prefix_prop() != null) {
									if (ctx.ring_prefix_prop().CARBOCYCLIC() != null && a.getSymbol().equals("C")) {
										target = ring;
									} else {
										target = null;
										break;
									}
									if (ctx.ring_prefix_prop().HETEROCYCLIC() != null && !a.getSymbol().equals("C")) {
										target = ring;
										break;
									} else {
										target = null;
										break;
									}
								} else {
									if (isRingFound) {
										break;
									}
								}
							}
							if (isRingFound) {
								break;
							}
						}
					}
					if (target != null) {
						for (IAtom a : target.atoms()) {
							res.add(a);
						}
					}
				//}
			}
		} catch (CDKException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		//System.out.println("res:"+res);
		return new Value(res);
	}
	
	public Value visitAtom_on_bond(SliceParser.Atom_on_bondContext ctx) {
		List<IChemObject> atoms = new ArrayList<IChemObject>();
		List<IChemObject> list = visit(ctx.getChild(2)).asIChemObjectList();
		
		for (IChemObject obj : list) {
			IBond bond = (IBond) obj;
			atoms.add(bond.getBegin());
			atoms.add(bond.getEnd());		
		}
		return new Value(atoms);
	}
	
	public Value visitBond_on_atom(SliceParser.Bond_on_atomContext ctx) {
		List<IChemObject> bonds = new ArrayList<IChemObject>();
		List<IChemObject> list = visit(ctx.getChild(2)).asIChemObjectList();
		
		for (IChemObject obj : list) {
			IAtom atom = (IAtom) obj;
			bonds.addAll(ac.getConnectedBondsList(atom))	;
		}
		return new Value(bonds);
	}

	private int quantitativeComparison(int count, int target) {
		switch (operatorType) {
		case 1:
			return count >= target ? 2 : -2;
		case 2:
			return count <= target ? 2 : -2;
		case 3:
			return count < target ? 2 : -2;
		case 4:
			return count > target ? 2 : -2;
		case 7:
			return count == target ? 2 : -2;
		}
		return 0;
	}
	private int quantitativeComparisonGroup(int count, int target) {
		switch (operatorType) {
		case 1:
			return count >= target ? 1 : -1;
		case 2:
			return count <= target ? 1 : -1;
		case 3:
			return count < target ? 1 : -1;
		case 4:
			return count > target ? 1 : -1;
		case 7:
			return count == target ? 1 : -1;
		}
		return 0;
	}
	private List<IChemObject> unpack(Value v, List<IChemObject> obj) {
		if (v.type() != null) {
			obj.add(v.right().asIChemObject());
			if (v.left().type() != null) {
				return unpack(v.left(), obj);
			} else {
				obj.add(v.left().asIChemObject());
				return obj;
			}
		}
		return obj;
	}

	private Map<Integer, Boolean> setWhereConfig(SliceParser.Where_stmtContext ctx) {
		Map<Integer, Boolean> config = new HashMap<Integer, Boolean>();
		if (ctx == null) {
			/*
			 * config.put(ChemConstants.ONPATH, null); config.put(ChemConstants.OFFPATH,
			 * null); config.put(ChemConstants.ONRING, null);
			 * config.put(ChemConstants.OFFRING, null);
			 * config.put(ChemConstants.ONTHEBRIDGE, null);
			 * config.put(ChemConstants.OFFTHEBRIDGE, null);
			 */
		} else {
			if (ctx.ONPATH() != null && ctx.OFFPATH() == null) {
				config.put(SliceConstants.ONPATH, true);
				config.put(SliceConstants.OFFPATH, false);
			} else if (ctx.OFFPATH() != null && ctx.ONPATH() == null) {
				config.put(SliceConstants.OFFPATH, true);
				config.put(SliceConstants.ONPATH, false);
			} else if (ctx.OFFPATH() != null && ctx.ONPATH() != null) {
				config.put(SliceConstants.OFFPATH, true);
				config.put(SliceConstants.ONPATH, true);
			} else {
				// config.put(ChemConstants.OFFPATH, null);
				// config.put(ChemConstants.ONPATH, null);
			}
			if (ctx.ONRING() != null && ctx.OFFRING() == null) {
				config.put(SliceConstants.ONRING, true);
				config.put(SliceConstants.OFFRING, false);
			} else if (ctx.OFFRING() != null && ctx.ONRING() == null) {
				config.put(SliceConstants.OFFRING, true);
				config.put(SliceConstants.ONRING, false);
			} else if (ctx.OFFRING() != null && ctx.ONPATH() != null) {
				config.put(SliceConstants.OFFRING, true);
				config.put(SliceConstants.ONRING, true);
			} else {
				// config.put(ChemConstants.OFFRING, null);
				// config.put(ChemConstants.ONRING, null);
			}
			/*
			 * if (ctx.ON_CURRENT_RING() != null) config.put(ChemConstants.ONCURRENTRING,
			 * true); else config.put(ChemConstants.ONCURRENTRING, false); if
			 * (ctx.OFF_CURRENT_RING() != null) config.put(ChemConstants.OFFCURRENTRING,
			 * true); else config.put(ChemConstants.OFFCURRENTRING, false);
			 */
			if (ctx.ON_THE_BRIDGE() != null && ctx.OFF_THE_BRIDGE() == null) {
				config.put(SliceConstants.ONTHEBRIDGE, true);
				config.put(SliceConstants.OFFTHEBRIDGE, false);
			}
			if (ctx.OFF_THE_BRIDGE() != null && ctx.ON_THE_BRIDGE() == null) {
				config.put(SliceConstants.OFFTHEBRIDGE, true);
				config.put(SliceConstants.ONTHEBRIDGE, false);
			} else if (ctx.OFF_THE_BRIDGE() != null && ctx.ON_THE_BRIDGE() != null) {
				config.put(SliceConstants.OFFTHEBRIDGE, true);
				config.put(SliceConstants.ONTHEBRIDGE, true);
			} else {
				// config.put(ChemConstants.OFFTHEBRIDGE, null);
				// config.put(ChemConstants.ONTHEBRIDGE, null);
			}
			// System.out.println("conf "+config.get(ChemConstants.ONPATH) + " " +
			// config.get(ChemConstants.OFFPATH));
		}
		return config;
	}

	private boolean isWhereRight(IAtom atom, Map<Integer, Boolean> conf) {
		// System.out.println(conf);
		// System.out.println(atom.getProperties());
		for (Entry<Integer, Boolean> e : conf.entrySet()) {
			int key = e.getKey();
			Boolean value = e.getValue();
			if (value != null) {
				if (!atom.getProperty(key).equals(value))
					return false;
			}
		}
		return true;
	}
	
	// Set ANYWHERE by default (ONPATH and OFFPATH set as true)
	private Map<Integer, Boolean> initWhereConfig() {
		Map<Integer, Boolean> config = new HashMap<Integer, Boolean>();
		config.put(SliceConstants.ONPATH, true);
		config.put(SliceConstants.OFFPATH, true);
		//config.put(SliceConstants.ONRING, false);
		//config.put(SliceConstants.OFFRING, false);
		// config.put(ChemConstants.ONCURRENTRING, false);
		// config.put(ChemConstants.OFFCURRENTRING, false);
		//config.put(SliceConstants.ONTHEBRIDGE, false);
		//config.put(SliceConstants.OFFTHEBRIDGE, false);
		return config;
	}

	private String getTokenName(int token) {
		return SliceParser.tokenNames[token];
	}

	private double alphaNumToNum(String alphaNum) {
		switch (alphaNum) {
		case "ZERO":
			return 0.0;
		case "ONE":
			return 1.0;
		case "TWO":
			return 2.0;
		case "THREE":
			return 3.0;
		case "FOUR":
			return 4.0;
		case "FIVE":
			return 5.0;
		case "SIX":
			return 6.0;
		case "SEVEN":
			return 7.0;
		case "EIGHT":
			return 8.0;
		case "NINE":
			return 9.0;
		case "TEN":
			return 10.0;
		case "ELEVEN":
			return 11.0;
		case "TWELVE":
			return 12.0;
		}
		return 0.0;
	}

	private boolean areBothAtomEqual(IAtom atom1, IAtom atom2) {
		if (atom1.getSymbol().equals(atom2.getSymbol()) && atom1.getFormalCharge() == atom2.getFormalCharge())
			return true;
		else
			return false;
	}

	private boolean areBothBondEqual(IBond bond1, IBond bond2) {
		if (bond1.getOrder().equals(bond2.getOrder()) && bond1.getStereo().equals(bond2.getStereo()))
			return true;
		else
			return false;
	}

	// TODO enlever typage comme hybridization 9 faire une cleaning function pour
	// comparer uniquement le type d'atom et de liaisons et leur enchqinement
	private boolean areBothAtomContainerEqual(IAtomContainer ac1, IAtomContainer ac2) throws CDKException {
		IFingerprinter fcfp = new CircularFingerprinter(CircularFingerprinter.CLASS_FCFP6);
		IFingerprinter ecfp = new CircularFingerprinter(CircularFingerprinter.CLASS_ECFP6);
		if (fcfp.getFingerprint(ac1).equals(fcfp.getBitFingerprint(ac2))
				&& ecfp.getFingerprint(ac1).equals(ecfp.getBitFingerprint(ac2)))
			return true;
		else
			return false;
	}

	public int getRating() {
		return rating;
	}
	
	/*public int getRatingOccurence() {
		int number_occurence = slighlty;
		if(moderately > number_occurence)
			number_occurence = moderately;
		if(strongly > number_occurence)
			number_occurence = strongly;
		if(severely > number_occurence)
			number_occurence = severely;
		return number_occurence;
	}*/
	public int getRatingOccurence() {
		return strongly + severely;
	}

	public boolean isKill() {
		return kill;
	}

	public void setCarbonCentered(Boolean carbonCentered) {
		this.carbonCentered = carbonCentered;
	}

}
